# Managing Test Isolation

TODO

It's a good practice to start Testcontainers only once per test session;
it takes time for containers to start, so recreating them after every test will negatively impact test performance.
However, starting the containers once per test session creates challenges with managing isolation between tests -
ensuring that data generated by previously run tests doesn't impact the outcome of another test.

There are multiple approaches for managing test isolation:

- Restart containers after every test so that applications always start from a known clean state - the easiest but the slowest approach.
  Remove `scope="session"` from Testcontainer's `@pytest.fixture` definition.

- Truncating/recreating datastores after every test - faster than restarting the entire container.
  For example, we could recreate an S3 bucket or database table after every test.

- Managing test isolation with the application means - the fastest approach, but it might not be feasible in all use cases.
  Most applications have a way of managing their data isolation, e.g., applications that scope what data a logged-in user can see.

TODO
Django test client can run each test in a database transaction and rollback it on teardown.
With Testcontainers, we can't interact with the low-level internals of the apps, so we take different approaches.
