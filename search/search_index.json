{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tomodachi Testcontainers","text":"<p>Tomodachi Testcontainers is a Python library built on top of testcontainers-python. It provides Testcontainers, pytest fixtures, and test clients for convenient use of Testcontainers with pytest and testing applications built with the Python Tomodachi framework.</p> <p>This library was created to explore and learn Testcontainers. Although initially intended to be used with the Tomodachi framework, it works for testing applications built with any other Python framework like Flask, FastAPI, Django, etc.</p>"},{"location":"#what-is-testcontainers","title":"What is Testcontainers?","text":"<p>Testcontainers is an open-source framework for providing throwaway, lightweight instances of databases, message brokers, web browsers, or just about anything that can run in a Docker container. It facilitates the use of Docker containers for functional, integration, and end-to-end testing. \u2014 https://testcontainers.com/</p> <p>To learn more about what Testcontainers are and what problems they solve, take a look at the Getting Started guide in the official Testcontainers documentation - https://testcontainers.com/getting-started/</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Find documentation at https://filipsnastins.github.io/tomodachi-testcontainers/</p> <p>The official Testcontainers documentation is at https://testcontainers.com/</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install tomodachi-testcontainers\n</code></pre> <p>Install with Poetry:</p> <pre><code>poetry add --group dev tomodachi-testcontainers\n</code></pre> <p>Find a list of extras in the installation reference.</p>"},{"location":"#a-simple-example","title":"A Simple Example","text":"<p>The <code>hello, world</code> Tomodachi service:</p> <pre><code># src/hello.py\nimport tomodachi\nfrom aiohttp import web\n\n\nclass Service(tomodachi.Service):\n    @tomodachi.http(\"GET\", r\"/hello/?\")\n    async def hello(self, request: web.Request) -&gt; web.Response:\n        name = request.query.get(\"name\", \"world\")\n        return web.json_response({\"message\": f\"Hello, {name}!\"})\n</code></pre> <ul> <li><code>testcontainer_image</code> fixture builds a Docker image with a Dockerfile from the current working directory.</li> <li><code>tomodachi_container</code> fixture starts a new Docker container running the <code>hello</code> service on a randomly available port.</li> <li><code>test_hello_testcontainers</code> sends a <code>GET /hello?name=Testcontainers</code> request to the running container and asserts the response.</li> </ul> <pre><code># tests/test_hello.py\nfrom typing import Generator\n\nimport httpx\nimport pytest\n\nfrom tomodachi_testcontainers import DockerContainer, TomodachiContainer\n\n\n@pytest.fixture(scope=\"session\")\ndef tomodachi_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with TomodachiContainer(testcontainer_image).with_command(\n        \"tomodachi run readme/hello.py --production\"\n    ) as container:\n        yield container\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hello_testcontainers(tomodachi_container: TomodachiContainer) -&gt; None:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        response = await client.get(\"/hello\", params={\"name\": \"Testcontainers\"})\n\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, Testcontainers!\"}\n</code></pre>"},{"location":"#links","title":"Links","text":"<ul> <li>Documentation: https://filipsnastins.github.io/tomodachi-testcontainers/</li> <li>Releases and Changelog: https://github.com/filipsnastins/tomodachi-testcontainers/releases</li> <li>PyPI: https://pypi.org/project/tomodachi-testcontainers/</li> <li>Source Code: https://github.com/filipsnastins/tomodachi-testcontainers</li> <li>Reference - Code API: https://filipsnastins.github.io/tomodachi-testcontainers/reference/</li> </ul>"},{"location":"configuration-options/","title":"Configuration Options","text":"<p>Note</p> <p>Ensure that environment variables are set before running <code>pytest</code>, e.g., with pytest-env plugin.</p>"},{"location":"configuration-options/#general-configuration-options","title":"General configuration options","text":"Environment Variable Description <code>&lt;CONTAINER-NAME&gt;_TESTCONTAINER_IMAGE_ID</code> Override Testcontainer's default Docker Image ID in pytest fixture. <code>DOCKER_BUILDKIT</code> Set <code>DOCKER_BUILDKIT=1</code> to use Docker BuildKit for building Docker images. <code>TESTCONTAINER_DOCKER_NETWORK</code> Launch Testcontainers in specified Docker network. Defaults to <code>bridge</code>. <code>&lt;CONTAINER-NAME&gt;_TESTCONTAINER_DISABLE_LOGGING</code> Disables log forwarding to stdout for given container."},{"location":"configuration-options/#override-default-docker-image-in-pytest-fixtures","title":"Override Default Docker Image in pytest fixtures","text":"pytest fixture Default Image Image Environment Variable Override <code>testcontainer_image</code> n/a, built from Dockerfile <code>TESTCONTAINER_IMAGE_ID</code> <code>moto_container</code> <code>motoserver/moto:latest</code> <code>MOTO_TESTCONTAINER_IMAGE_ID</code> <code>localstack_container</code> <code>localstack/localstack:3</code> <code>LOCALSTACK_TESTCONTAINER_IMAGE_ID</code> <code>minio_container</code> <code>minio/minio:latest</code> <code>MINIO_TESTCONTAINER_IMAGE_ID</code> <code>sftp_container</code> <code>atmoz/sftp:latest</code> <code>SFTP_TESTCONTAINER_IMAGE_ID</code> <code>wiremock_container</code> <code>wiremock/wiremock:latest</code> <code>WIREMOCK_TESTCONTAINER_IMAGE_ID</code> <code>mysql_container</code> <code>mysql:8</code> <code>MYSQL_TESTCONTAINER_IMAGE_ID</code> <code>postgres_container</code> <code>postgres:16</code> <code>POSTGRES_TESTCONTAINER_IMAGE_ID</code>"},{"location":"configuration-options/#change-the-default-docker-network","title":"Change the default Docker network","text":"<p>By default, Testcontainers are started in the default <code>bridge</code> Docker network. Sometimes, starting containers in a different network is useful, e.g., to isolate parallel test runs. Specify a new network name with the <code>TESTCONTAINER_DOCKER_NETWORK</code> environment variable. The Docker network is not created automatically, so ensure it exists before running tests.</p>"},{"location":"configuration-options/#testcontainer_image-fixture-configuration","title":"<code>testcontainer_image</code> fixture configuration","text":"Environment Variable Description <code>TESTCONTAINER_IMAGE_ID</code> Use given Image ID for creating a container. <code>TESTCONTAINER_DOCKERFILE_PATH</code> Override path to the Dockerfile for building Docker image. <code>TESTCONTAINER_DOCKER_BUILD_CONTEXT</code> Override Docker build context. <code>TESTCONTAINER_DOCKER_BUILD_TARGET</code> Override Docker build target."},{"location":"configuration-options/#change-the-dockerfile-path-build-context-and-build-target","title":"Change the Dockerfile path, build context, and build target","text":"<p>If the Dockerfile is not located in the current working directory or you need a different Docker build context, specify a new path with the <code>TESTCONTAINER_DOCKERFILE_PATH</code> and <code>TESTCONTAINER_DOCKER_BUILD_CONTEXT</code> environment variables.</p> <p>Examples:</p> <ul> <li><code>TESTCONTAINER_DOCKERFILE_PATH=examples/Dockerfile.testing</code></li> <li><code>TESTCONTAINER_DOCKER_BUILD_CONTEXT=examples/</code></li> </ul> <p>If you have a multi-stage Dockerfile and want to run tests against a specific Docker image stage, specify the stage name with the <code>TESTCONTAINER_DOCKER_BUILD_TARGET</code> environment variable. Note that it's a best practice to run tests against the release/production stage, so this environment variable is not needed in most cases, as it's usually the last stage in a Dockerfile.</p> <p>Example:</p> <ul> <li><code>TESTCONTAINER_DOCKER_BUILD_TARGET=development</code></li> </ul>"},{"location":"configuration-options/#run-testcontainer-from-the-pre-built-image","title":"Run Testcontainer from the pre-built image","text":"<p>If the Testcontainer's Docker image is already built, you can run it in the container by specifying the Image ID in the <code>TESTCONTAINER_IMAGE_ID</code> environment variable.</p> <p>It is useful for running tests in the deployment pipeline when the image has already been built on the <code>build</code> step. Instead of building a new image from scratch for the tests, we want to test the same image that will be pushed to a Container Registry and deployed to production.</p> <p>Examples:</p> <ul> <li><code>TESTCONTAINER_IMAGE_ID=sha256:56ca9586de1cf25081bb5f070b59b86625b6221bb26d7409a74e6051d7954c92</code></li> <li><code>TESTCONTAINER_IMAGE_ID=mycompany/my-application:1.0.0</code></li> </ul>"},{"location":"configuration-options/#included-testcontainers-configuration","title":"Included Testcontainers configuration","text":"<p>Testcontainer configuration can be changed by setting these environment variables on a host machine. It's handy when you want to change the default configuration of Testcontianers when using their pytest fixtures.</p> <ul> <li> <p><code>LocalStackContainer</code></p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>AWS_ACCESS_KEY_ID</code> - defaults to <code>testing</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code> - defaults to <code>testing</code></li> </ul> </li> <li> <p><code>MototContainer</code></p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>AWS_ACCESS_KEY_ID</code> - defaults to <code>testing</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code> - defaults to <code>testing</code></li> </ul> </li> <li> <p><code>MinioContainer</code></p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>MINIO_ROOT_USER</code> - defaults to <code>minioadmin</code></li> <li><code>MINIO_ROOT_PASSWORD</code> - defaults to <code>minioadmin</code></li> </ul> </li> <li> <p><code>MySQLContainer</code></p> <ul> <li><code>MYSQL_DRIVERNAME</code> - defaults to <code>mysql+pymysql</code></li> <li><code>MYSQL_USER</code> - defaults to <code>username</code></li> <li><code>MYSQL_ROOT_PASSWORD</code> - defaults to <code>root</code></li> <li><code>MYSQL_PASSWORD</code> - defaults to <code>password</code></li> <li><code>MYSQL_DATABASE</code> - defaults to <code>db</code></li> </ul> </li> <li> <p><code>PostgreSQLContainer</code></p> <ul> <li><code>POSTGRES_DRIVERNAME</code> - defaults to <code>postgresql+psycopg</code></li> <li><code>POSTGRES_USER</code> - defaults to <code>username</code></li> <li><code>POSTGRES_PASSWORD</code> - defaults to <code>password</code></li> <li><code>POSTGRES_DB</code> - defaults to <code>db</code></li> </ul> </li> <li> <p><code>TomodachiContainer</code></p> <ul> <li><code>TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE</code> - defaults to <code>False</code></li> </ul> </li> <li> <p><code>WireMockContainer</code></p> <ul> <li><code>WIREMOCK_TESTCONTAINER_MAPPING_STUBS</code> - path to WireMock mapping stubs, defaults to <code>None</code></li> <li><code>WIREMOCK_TESTCONTAINER_MAPPING_FILES</code> - path to WireMock mapping files, defaults to <code>None</code></li> <li><code>WIREMOCK_TESTCONTAINER_VERBOSE</code> - set to <code>1</code> to start WireMock in verbose mode, defaults to <code>None</code></li> </ul> </li> </ul>"},{"location":"development/","title":"Development","text":"<ul> <li>Install dev dependencies with Poetry.</li> </ul> <pre><code>poetry install --all-extras --with dev,docs\npoetry shell\npre-commit install\n</code></pre> <ul> <li>Run tests.</li> </ul> <pre><code>docker network create tomodachi-testcontainers\n\nmake test  # Run tests during development\nmake test-docs-src  # Test documentation code examples\nmake test-ci  # Run all tests with code coverage\n</code></pre> <ul> <li>Format and lint code.</li> </ul> <pre><code>make format\nmake lint\n</code></pre> <ul> <li>Run all commit hooks at once.</li> </ul> <pre><code>make hooks\n</code></pre> <ul> <li>Build package release.</li> </ul> <pre><code>poetry build\n</code></pre> <ul> <li>Develop documentation with Material for MkDocs.</li> </ul> <pre><code>mkdocs serve\n</code></pre> <ul> <li>Generate C4 diagrams with PlantUML (get plantuml.jar at https://plantuml.com/starting).</li> </ul> <pre><code>export JAVA_HOME=`/usr/libexec/java_home -v 21`\n\njava -jar plantuml.jar -DRELATIVE_INCLUDE=\".\" docs/**/*.puml\n</code></pre> <ul> <li>Run PlantUML server.</li> </ul> <pre><code>docker run -d -p 8080:8080 plantuml/plantuml-server:jetty\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#containers","title":"Containers","text":"<p>See the list of available Testcontainers at <code>tomodachi_testcontainers</code>. Find more Testcontainers in the official testcontainers-python library. See Creating New Testcontainers for adding new Testcontainers.</p>"},{"location":"features/#pytest-fixtures-and-helpers","title":"Pytest fixtures and helpers","text":"<p>Ready-made pytest fixtures make testing your applications simple. Find the complete list of available fixtures at <code>tomodachi_testcontainers.fixtures</code>.</p> <ul> <li> <p><code>testcontainer_image</code>   fixture builds a Docker image with a Dockerfile from the current working directory.   It allows you to run the latest version of our application as a Docker container for automated testing.</p> </li> <li> <p>Launch commonly used Testcontainers with fixtures, e.g.,   <code>localstack_container</code>,   <code>postgres_container</code>,   etc.</p> </li> <li> <p>Get fixtures for interacting with Testcontainers, e.g., <code>localstack_s3_client</code>, <code>moto_dynamodb_client</code>, etc.</p> </li> </ul> <p>Async probes for testing asynchronous systems - <code>tomodachi_testcontainers.async_probes</code>. Inspired by Awaitility and busypie.</p> <p>Assertion helpers for common test cases like asserting for logs in a Docker container - <code>tomodachi_testcontainers.assertions</code>.</p> <p>Utility functions in <code>tomodachi_testcontainers.utils</code> for easier working with Testcontainers.</p>"},{"location":"features/#test-clients","title":"Test clients","text":"<p>Test clients allow you to test different modes of interactions with your applications.</p> <ul> <li><code>SNSSQSTestClient</code> helps test   Tomodachi applications that communicate through AWS SNS SQS.</li> </ul>"},{"location":"features/#logging","title":"Logging","text":"<p>Upon Testcontainers' shutdown, their logs are forwarded to Python's logger, making it possible to see what happened inside the containers. It's useful for debugging failing tests, especially in a deployment pipeline, because containers are immediately deleted when the test run finishes, leaving behind only their logs.</p>"},{"location":"features/#configuration","title":"Configuration","text":"<p>Most features are configurable with environment variables, e.g., a path to Dockerfile, Testcontainer image versions, etc. See all configuration options.</p>"},{"location":"included-testcontainers/","title":"Included Testcontainers","text":"<p>Below is the list of Testcontainers included in this library. Feel free to explore how they're implemented and create your Testcontainers when needed - see Creating new Testcontainers</p> Container Name Default Image Fixture <code>TomodachiContainer</code> n/a n/a <code>MotoContainer</code> <code>motoserver/moto:latest</code> <code>moto_container</code> <code>LocalStackContainer</code> <code>localstack/localstack:3</code> <code>localstack_container</code> <code>MinioContainer</code> <code>minio/minio:latest</code> <code>minio_container</code> <code>DynamoDBAdminContainer</code> <code>aaronshaf/dynamodb-admin:latest</code> n/a <code>SFTPContainer</code> <code>atmoz/sftp:latest</code> <code>sftp_container</code> <code>WireMockContainer</code> <code>wiremock/wiremock:latest</code> <code>wiremock_container</code> <code>MySQLContainer</code> <code>mysql:8</code> <code>mysql_container</code> <code>PostgreSQLContainer</code> <code>postgres:16</code> <code>postgres_container</code> <p>Note</p> <p>See configuration options for containers configuration settings.</p>"},{"location":"included-testcontainers/#tomodachi","title":"Tomodachi","text":"<p>Tomodachi - a lightweight microservices library on Python asyncio.</p> <p>Repository: https://github.com/kalaspuff/tomodachi</p>"},{"location":"included-testcontainers/#moto","title":"Moto","text":"<p>Moto is a library that allows your tests to mock out AWS Services.</p> <p>Repository: https://github.com/getmoto/moto</p> <p>Docker Hub: https://hub.docker.com/r/motoserver/moto</p>"},{"location":"included-testcontainers/#localstack","title":"LocalStack","text":"<p>LocalStack provides an easy-to-use test/mocking framework for developing cloud applications.</p> <p>Repository: https://github.com/localstack/localstack</p> <p>DockerHub: https://hub.docker.com/r/localstack/localstack</p>"},{"location":"included-testcontainers/#minio","title":"Minio","text":"<p>MinIO is a High Performance Object Storage released under GNU Affero General Public License v3.0. It is API compatible with Amazon S3 cloud storage service.</p> <p>Repository: https://github.com/minio/minio</p> <p>DockerHub: https://hub.docker.com/r/minio/minio</p>"},{"location":"included-testcontainers/#dynamodb-admin","title":"DynamoDB Admin","text":"<p>GUI for DynamoDB Local, dynalite, localstack etc. Useful for exploring DynamoDB tables and data during development and testing.</p> <p>Repository: https://github.com/aaronshaf/dynamodb-admin</p> <p>DockerHub: https://hub.docker.com/r/aaronshaf/dynamodb-admin</p>"},{"location":"included-testcontainers/#sftp","title":"SFTP","text":"<p>Easy to use SFTP (SSH File Transfer Protocol) server with OpenSSH.</p> <p>Repository: https://github.com/atmoz/sftp</p> <p>DockerHub: https://hub.docker.com/r/atmoz/sftp</p> <ul> <li>Available as an extra dependency <code>sftp</code> - <code>pip install tomodachi-testcontainers[sftp]</code>.</li> </ul>"},{"location":"included-testcontainers/#wiremock","title":"WireMock","text":"<p>WireMock is a tool for building mock APIs. Create stable development environments, isolate yourself from flaky 3rd parties and simulate APIs that don't exist yet.</p> <p>Repository: https://github.com/wiremock/wiremock</p> <p>DockerHub: https://hub.docker.com/r/wiremock/wiremock</p> <p>Python SDK: https://github.com/wiremock/python-wiremock</p> <ul> <li>WireMock Python SDK can be installed as an extra dependency <code>wiremock</code> - <code>pip install tomodachi-testcontainers[wiremock]</code>.</li> </ul>"},{"location":"included-testcontainers/#mysql","title":"MySQL","text":"<p>MySQL is a widely used, open-source relational database management system (RDBMS).</p> <p>DockerHub: https://hub.docker.com/_/mysql</p> <ul> <li>Available as an extra dependency <code>mysql</code> - <code>pip install tomodachi-testcontainers[mysql]</code>.</li> </ul>"},{"location":"included-testcontainers/#postgresql","title":"PostgreSQL","text":"<p>The PostgreSQL object-relational database system provides reliability and data integrity.</p> <p>DockerHub: https://hub.docker.com/_/postgres</p> <ul> <li>Available as an extra dependency <code>postgres</code> - <code>pip install tomodachi-testcontainers[postgres]</code>.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Install with pip:</p> <pre><code>pip install tomodachi-testcontainers\n</code></pre> <p>Install with Poetry:</p> <pre><code>poetry add --group dev tomodachi-testcontainers\n</code></pre> <p>Extra packages:</p> <pre><code># Generic DatabaseContainer and SQLAlchemy\npip install tomodachi-testcontainers[db]\n\n# MySQLContainer, SQLAlchemy and pymysql\npip install tomodachi-testcontainers[mysql]\n\n# PostgreSQLContainer, SQLAlchemy and psycopg\npip install tomodachi-testcontainers[postgres]\n\n# SFTPContainer and asyncssh\npip install tomodachi-testcontainers[sftp]\n\n# Installs python-wiremock SDK\npip install tomodachi-testcontainers[wiremock]\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Info</p> <p>See the Getting Started section for a complete walkthrough.</p> <p>Service examples are in the examples/ folder; their tests written with Testcontainers are in tests/services/.</p> <p>For a complete list of available Testcontainers, see:</p> <ul> <li>Included Testcontainers page.</li> <li>tomodachi_testcontainers.containers module.</li> <li>Official testcontainers-python library.</li> </ul> <p>Find available <code>pytest</code> fixtures in the tomodachi_testcontainers.fixtures module and test clients in the tomodachi_testcontainers.clients module.</p>"},{"location":"resources-and-acknowledgements/","title":"Resources and Acknowledgments","text":"<ul> <li> <p>testcontainers.com - Testcontainers official site.</p> </li> <li> <p>testcontainers-python - official Python SDK for Testcontainers.</p> </li> <li> <p>Talk \"Integration tests are needed and simple\" by Piotr Przybyl.</p> </li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>This section describes common errors you might encounter working with Testcontainers in the Python environment.</p> Error on running tests with pytest: <code>ScopeMismatch: You tried to access the function scoped fixture event_loop with a session scoped request object, involved factories.</code> <p>Problem: the error occurs when you're using asynchronous fixtures with a scope higher than <code>function</code>, e.g., fixture <code>moto_container</code> has <code>session</code> scope. The default <code>event_loop</code> fixture provided by <code>pytest-asyncio</code> is a function-scoped fixture, so it can't be used with session-scoped fixtures.</p> <p>Solution: override the <code>event_loop</code> fixture with a session-scoped fixture by placing it in your project's default <code>conftest.py</code>.</p> tests/conftest.py<pre><code>\n</code></pre>"},{"location":"getting-started/applying-e2e-tests-with-testcontainers/","title":"Applying End-to-End Tests With Testcontainers","text":"<p>After going through the guides and examples, you might ask, where do end-to-end tests with Testcontainers fit into the whole application's testing strategy? There's no universal answer, so this section will do its best to outline some pointers toward better and more reliable application testing.</p>"},{"location":"getting-started/applying-e2e-tests-with-testcontainers/#building-confidence-in-automated-tests","title":"Building confidence in automated tests","text":"<p>Automated tests must give us confidence that the system is in a releasable state - it does what the system users want (user-focused tests) and does that right (developer-focused tests). The tests are of little value if they're passing, but the application doesn't work for the actual users. Therefore, the system must be tested in a production-like environment close to real-world usage. The specific test tools and frameworks matter less than building confidence that the automated test suite is robust and trustworthy.</p> <p>Testcontainers are a tool for creating an isolated, controlled, and production-like test environment without the disadvantages of depending on complex and shared staging environments. With Testcontainers, we can test an application in a production-like environment, building confidence that the application will work for real users.</p> <p>Since such end-to-end tests tend to be lengthy to write and sometimes tricky to set up, e.g., when an application has a lot of external dependencies. You need to make a conscious choice about how many such tests you want to have. There's no correct answer here, so let's look at different approaches and their benefits and disadvantages.</p>"},{"location":"getting-started/applying-e2e-tests-with-testcontainers/#using-end-to-end-tests-to-ensure-correct-integration-of-the-systems-components","title":"Using end-to-end tests to ensure correct integration of the system's components","text":"<p>One of the Testcontainer end-to-end test applications is ensuring that all system's components are configured and working together correctly. It's useful to test because applications depend on many other libraries and tools. Although the external components are tested individually by their developers, we still must ensure that our application uses them correctly.</p> <p>To ensure that all system components are configured correctly, we'll write a limited amount of end-to-end tests and touch all system integration points. The book Architecture Patterns with Python (Harry Percival and Bob Gregory) describes a useful rule of thumb for the use of different types of tests:</p> <ul> <li> <p>Aim for one end-to-end test per feature; error handling counts as a feature - it suggests using end-to-end tests to demonstrate that the feature works   and all the system components that build the feature are working together correctly.   It means that end-to-end tests shouldn't be used as the main way of testing the system due to their cost and brittleness   but rather as a way to supplement other tests - service layer tests and unit tests.</p> </li> <li> <p>Write the bulk of your tests against the service layer; maintain a small core of tests written against your domain model -   if you keep your application's business logic decoupled from the framework, e.g., Django,   you can test most of the system without the need to rely on slow, real dependencies.   You can use fakes and mocks to simulate input/output (databases, message brokers, external systems) and focus tests on the core business logic.</p> </li> </ul> <p>It is important to note that end-to-end tests should focus on testing the application's public API rather than internal implementation details, for example, what data was saved to the PostgreSQL database table. A single end-to-end test might call multiple API endpoints, exercising the whole system and simulating a realistic user's journey. Focus on testing user behaviors rather than individual application endpoints.</p> <p>Note</p> <p>The Architecture Patterns with Python book neatly describes patterns for building robust and testable applications. I highly recommend this as an introduction to building clean and maintainable systems. Also, the book is free! \ud83d\udcd6</p>"},{"location":"getting-started/applying-e2e-tests-with-testcontainers/#using-end-to-end-tests-as-a-base-for-the-systems-test-strategy","title":"Using end-to-end tests as a base for the system's test strategy","text":"<p>Test Pyramid is a famous way of thinking about testing - most tests are isolated unit tests, fewer tests are integration/service tests, and the least amount of tests are end-to-end/UI tests. This approach is often used when testing monolithic applications.</p> <p>When using more service-oriented architectures like microservices, individual applications are smaller, so the forces behind the Test Pyramid change - there's less need to segregate tests in unit/integration/end-to-end because the amount of tests is also smaller. Testing Honeycomb proposed at Spotify is a different mental model for thinking about testing microservices. Read the full article - Testing of Microservices on Spotify Engineering Blog.</p> <p>It's important to remember not to get caught up in the debates between different testing shapes and the correct number of test types. Focus on the value of the tests - that the system does what users want (user-focused tests) and does it right (developer-focused tests). Read up On the Diverse And Fantastical Shapes of Testing on Martin Fowler's site.</p>"},{"location":"getting-started/applying-e2e-tests-with-testcontainers/#next-steps","title":"Next Steps","text":"<p>I hope that this introduction to Testcontainers and end-to-end tests was useful. It wasn't meant to be an exhaustive guide to automated testing, so I'll leave some valuable and free resources about application testing for further reading:</p> <ul> <li>Testing for Software Engineers by Mikael Vesavuori.</li> <li>Architecture Patterns with Python by Harry Percival and Bob Gregory.</li> <li>Test-Driven Development with Python by Harry Percival.</li> <li>Software Testing Guide by Martin Fowler.</li> </ul> <p>If you want to continue exploring Testcontainers, check out the Guides section and the official Testcontainers site. \ud83d\udc4b</p>"},{"location":"getting-started/testing-app-with-backing-services/","title":"Testing Applications with Backing Services","text":"<p>Applications don't live in isolation. They depend on other backing services - databases, file exchanges, cloud provider services, third-party services, etc. It makes testing difficult - the test environment must have a lot of things configured for the application to work. Remember spending hours setting up a local development environment?</p>"},{"location":"getting-started/testing-app-with-backing-services/#running-backing-services-locally","title":"Running backing services locally","text":"<p>You should be able to run your application's tests on your local machine to get fast feedback about the changes. Imagine how the workflow would look if the tests worked only in the deployment pipeline - you had to push changes to version control and wait for the CI server to finish the build every time you wanted to verify a small code change. It would create unnecessary friction for integrating automated testing into the development workflow.</p> <p>That's where Testcontainers are very useful - they automate the creation of the application's dependencies. They're run as Docker containers and are thrown away when tests finish. Testcontainers make configuration of your local development environment easy - all its components are defined as code in the same repository and created the same way every time you run the tests.</p> <p>Run tests locally</p> <p>Design your tests so they run locally without any additional configuration. Make the test fixtures configure backing services automatically with Testcontainers.</p>"},{"location":"getting-started/testing-app-with-backing-services/#running-production-like-versions-of-backing-services","title":"Running production-like versions of backing services","text":"<p>Tests should give us confidence that an application will work in a production environment. The tests are of little value if they're passing, but the application doesn't work for the actual users. One of the key elements for creating reliable tests is making the development and testing environment as similar to production as possible. To achieve dev/prod parity, apart from using production-like data and configuration, we must run the same versions of backing services in the development environment as in production. For example, we can run the same versions of databases like PostgreSQL or MongoDB and message brokers like RabbitMQ (see the Testing Databases guide for more examples). However, it gets more complicated when an application depends on proprietary software or managed cloud services that can't be run locally, for example, AWS S3 file store or AWS SNS/SQS message broker.</p> <p>When a dependency can't be run locally, e.g., because it's a managed cloud provider service like AWS S3, we have other testing options:</p> <ul> <li>Using a real version of an external service, e.g., testing with a real AWS account.</li> <li>Mocking the interactions with an external service, e.g., with Python's <code>unittest.mock</code>.</li> <li>Using verified external mocks, e.g., LocalStack and Moto, for emulating the AWS cloud.</li> </ul> <p>Using a real AWS account for testing is the most production-like way. Such tests must use a dedicated AWS account only for autotests and have safeguards that they're not accidentally connected to a production account. There's a risk of changing production resources if tests are misconfigured. Using real services will create additional costs in cloud bills and maintenance time that need to be accounted for. Lastly, the tests will be slower because they'll communicate over the external network and might become flaky if multiple test suites are using the same resources simultaneously. Ultimately, using the real services shouldn't be your default choice due to the complexity and costs.</p> <p>The second option is mocking the interactions with mocks, e.g., <code>unittest.mock</code>. This way, we verify that the code calls external dependency in a way we expect but doesn't verify if the call would succeed in the real environment. For example, we can mock calls to the AWS <code>boto3</code> client and remove any dependencies on the cloud service from the tests. The tests will be fast because there'll be no network calls. However, they won't ensure that the code will work in the real environment because we might accidentally misconfigure the mocks, and the tests won't notice that. Although unit tests are handy because of the low cost and fast runtime, they must be supplemented by other production-like tests.</p> <p>The last option - verified external mocks - combines the first two approaches. Since applications usually interact with cloud providers through its REST API, we can substitute the endpoint URL with a more sophisticated type of mock that can be run locally. From the application's perspective, it wouldn't know nor care that it's interacting with a fake service. What matters is that it behaves the same.</p> <p>Projects like LocalStack and Moto are web applications that emulate AWS cloud - they provide the same API and behavior for local development and testing. Similar tools exist for other cloud providers. Cloud emulators are tested separately against a real cloud provider to ensure they behave the same; hence, they're verified mocks. However, they're still not always accurate. You might encounter some corner cases where the mocks didn't catch a problem, and it surfaced only in a real environment. Check out LocalStack feature coverage and Moto supported services for more details. Despite that, such services are battle-tested, have extensive open-source community support, and are good enough for most use cases. Running cloud mocks with Testcontainers is easy because they're simply web applications. That's the route we'll take in the following sections of this guide.</p> <p>Lastly, it's worth mentioning that despite testing with verified mocks like LocalStack, you might stumble upon unsupported features or inaccurate behavior, or you are working with a critical part of the system where the cost of failure is high. For such cases, you might want to consider testing parts of your application with a real external dependency. Take all precautions - prefer running such tests only in a deployment pipeline, disable them locally, and always use a separate account dedicated only to automated testing. To make testing only certain parts of your application easy, modularize those components, for example, with the Ports &amp; Adapters pattern.</p> <p>Test with production-like dependencies</p> <p>Test your application with production-like dependencies with the same configuration for dev/prod parity.</p> <p>You can run the identical versions of some dependencies locally, e.g., PostgreSQL database or RabbitMQ message broker. Other dependencies, e.g., a managed cloud provider service, can't be run locally. Find an alternative for local development like LocalStack and Moto AWS cloud emulators.</p> <p>If you can't run a dependency locally and no alternatives for local development and testing exist, e.g., for Oracle Enterprise Database, resort to testing with a dedicated instance running in a separate test environment, or consult your software vendor.</p>"},{"location":"getting-started/testing-app-with-backing-services/#example-testing-file-store-application-with-aws-s3-and-localstack","title":"Example: Testing file store application with AWS S3 and LocalStack","text":"<p>Let's test an example file store application. The application provides a simple REST API for storing and retrieving text files. For a data store, the application uses AWS S3.</p> <p></p>"},{"location":"getting-started/testing-app-with-backing-services/#creating-the-file-store-application","title":"Creating the file store application","text":"<p>The example app has two endpoints - <code>POST /file</code> and <code>GET /file/&lt;name&gt;</code>. In the backend, the app uses AWS S3 operations <code>put_object</code> and <code>get_object</code> to store and retrieve files.</p> src/app.py<pre><code>import tomodachi\nfrom aiohttp import web\n\nfrom .aws import create_s3_client, get_bucket_name\n\n\nclass Service(tomodachi.Service):\n    async def _start_service(self) -&gt; None:\n        self._s3_client, self._s3_client_exit_stack = await create_s3_client()\n\n    async def _stop_service(self) -&gt; None:\n        await self._s3_client_exit_stack.aclose()\n\n    @tomodachi.http(\"POST\", r\"/file/?\")\n    async def save_file(self, request: web.Request) -&gt; web.Response:\n        body = await request.json()\n        filename = body[\"filename\"]\n        content = body[\"content\"]\n        await self._s3_client.put_object(Bucket=get_bucket_name(), Key=filename, Body=content)\n        return web.json_response({\"key\": filename})\n\n    @tomodachi.http(\"GET\", r\"/file/(?P&lt;key&gt;[^/]+?)/?\")\n    async def get_file(self, request: web.Request, key: str) -&gt; web.Response:\n        try:\n            s3_object = await self._s3_client.get_object(Bucket=get_bucket_name(), Key=key)\n            content = await s3_object[\"Body\"].read()\n            return web.json_response({\"content\": content.decode()})\n        except self._s3_client.exceptions.NoSuchKey:\n            return web.json_response({\"error\": \"FILE_NOT_FOUND\"}, status=404)\n</code></pre> <p>The app is configured with environment variables. The required configuration value is <code>AWS_S3_BUCKET_NAME</code> for specifying the bucket name for the datastore. Other optional values are <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> for credentials and <code>AWS_S3_ENDPOINT_URL</code> for overriding the AWS endpoint.</p> <p>We treat all backing services as attachable resources - they're substitutable by changing the application's configuration, such as the <code>AWS_S3_ENDPOINT_URL</code>. This approach makes testing and deployment to different environments possible. We can use other instances of backing services in different environments, including in automated testing.</p> src/aws.py<pre><code>import os\nfrom contextlib import AsyncExitStack\n\nfrom aiobotocore.session import get_session\nfrom types_aiobotocore_s3 import S3Client\n\nsession = get_session()\n\n\ndef get_bucket_name() -&gt; str:\n    return os.environ[\"AWS_S3_BUCKET_NAME\"]\n\n\nasync def create_s3_client() -&gt; tuple[S3Client, AsyncExitStack]:\n    exit_stack = AsyncExitStack()\n    client = await exit_stack.enter_async_context(\n        session.create_client(\n            \"s3\",\n            aws_access_key_id=os.getenv(\"AWS_ACCESS_KEY_ID\"),\n            aws_secret_access_key=os.getenv(\"AWS_SECRET_ACCESS_KEY\"),\n            endpoint_url=os.getenv(\"AWS_S3_ENDPOINT_URL\"),\n        )\n    )\n    return client, exit_stack\n</code></pre>"},{"location":"getting-started/testing-app-with-backing-services/#configuring-testcontainers","title":"Configuring Testcontainers","text":"<p>As in the previous guide - Testing Simple Application, the first step is creating Testcontainer fixtures. This example is more involved because the application depends on the external service - AWS cloud. Since we don't want to use the real AWS account for automated testing, we'll use a <code>LocalStackContainer</code>. We can access it with the <code>localstack_container</code> fixture.</p> <p>Next, we need to configure our application's container with environment variables. The important part is setting the environment variable <code>AWS_S3_ENDPOINT_URL</code> to the LocalStack URL. When the application uses AWS S3, it will send requests to the LocalStack instance running locally as a Docker container and not to the real AWS.</p> tests/conftest.py<pre><code>from typing import AsyncGenerator, Generator\n\nimport httpx\nimport pytest\nimport pytest_asyncio\n\nfrom tomodachi_testcontainers import DockerContainer, LocalStackContainer, TomodachiContainer\n\n\n@pytest.fixture(scope=\"session\")\ndef tomodachi_container(\n    testcontainer_image: str,\n    localstack_container: LocalStackContainer,\n) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        TomodachiContainer(testcontainer_image)\n        .with_env(\"AWS_S3_BUCKET_NAME\", \"autotest-my-bucket\")\n        .with_env(\"AWS_ACCESS_KEY_ID\", \"testing\")\n        .with_env(\"AWS_SECRET_ACCESS_KEY\", \"testing\")\n        .with_env(\"AWS_S3_ENDPOINT_URL\", localstack_container.get_internal_url())\n        .with_command(\"tomodachi run getting_started/s3/app.py --production\")\n    ) as container:\n        yield container\n\n\n@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def http_client(tomodachi_container: TomodachiContainer) -&gt; AsyncGenerator[httpx.AsyncClient, None]:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        yield client\n</code></pre> <p>Note</p> <p>The <code>localstack_container.get_internal_url()</code> returns a URL that's accessible only inside the Docker network so that the <code>LocalStackContainer</code> and <code>TomodachiContainer</code> can communicate with each other.</p> <p>How do I avoid tests from mutating my real infrastructure?</p> <p>When working with AWS mocks, it's important to have safeguards against accidentally mutating real infrastructure.</p> <p>On a host machine that's running tests, set AWS environment variables to dummy values, e.g., by using the <code>pytest-env</code> plugin. In addition, never embed real credentials in the code.</p> <pre><code>[tool.pytest.ini_options]\nenv = [\n    # Set dummy AWS credentials so that we don't accidentally mutate real infrastructure\n    \"AWS_REGION=us-east-1\",\n    \"AWS_DEFAULT_REGION=us-east-1\",\n    \"AWS_ACCESS_KEY_ID=testing\",\n    \"AWS_SECRET_ACCESS_KEY=testing\",\n    \"AWS_SECURITY_TOKEN=testing\",\n    \"AWS_SESSION_TOKEN=testing\",\n]\n</code></pre> <p>Read more in the Moto documentation.</p>"},{"location":"getting-started/testing-app-with-backing-services/#testing-the-applications-public-api","title":"Testing the application's public API","text":"<p>Let's write a test for storing files. First, we need to create the AWS S3 bucket in a LocalStack environment. Tomodachi Testcontainers provides fixtures for commonly used AWS clients, for example, <code>localstack_s3_client</code>. Having the <code>localstack_s3_client</code>, we can easily create the <code>autotest-my-bucket</code> S3 bucket. Next, we request the application to store the text <code>Hello, world!</code> in the file <code>test.txt</code>. Lastly, we assert that we got a correct response.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\nfrom types_aiobotocore_s3 import S3Client\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_save_file(http_client: httpx.AsyncClient, localstack_s3_client: S3Client) -&gt; None:\n    await localstack_s3_client.create_bucket(Bucket=\"autotest-my-bucket\")\n\n    response = await http_client.post(\"/file/\", json={\"filename\": \"test.txt\", \"content\": \"Hello, world!\"})\n\n    assert response.status_code == 200\n    assert response.json() == {\"key\": \"test.txt\"}\n</code></pre> <p>The first test worked fine, but we haven't actually tested that the file was stored. To verify that, we'd need to query the file and ensure it has the right content. An easy way to test that would be to query the S3 bucket and look at what's in there. It works; however, it creates a significant problem - we're testing the application's internal implementation details. Such tests are brittle - changing the inner details of how the files are stored in S3 could break the tests. Also, such tests are difficult to read - to write a test, we have to deal with all the mechanics and complexities of the infrastructure.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\nfrom types_aiobotocore_s3 import S3Client\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_save_file(http_client: httpx.AsyncClient, localstack_s3_client: S3Client) -&gt; None:\n    await localstack_s3_client.create_bucket(Bucket=\"autotest-my-bucket\")\n\n    response = await http_client.post(\"/file/\", json={\"filename\": \"test.txt\", \"content\": \"Hello, world!\"})\n    assert response.status_code == 200\n    assert response.json() == {\"key\": \"test.txt\"}\n\n    # Danger: testing application's internal implementation details\n    s3_object = await localstack_s3_client.get_object(Bucket=\"autotest-my-bucket\", Key=\"test.txt\")\n    content = await s3_object[\"Body\"].read()\n    assert content.decode() == \"Hello, world!\"\n</code></pre> <p>To fix the problem, we should test our application using its public API. Luckily, this application already has a file retrieval API that suits our needs - <code>GET /files/&lt;name&gt;</code>. The refactored test has a new name - <code>test_save_and_get_file</code> - because now we're storing the file and querying it in the same test.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\nfrom types_aiobotocore_s3 import S3Client\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_save_and_get_file(http_client: httpx.AsyncClient, localstack_s3_client: S3Client) -&gt; None:\n    await localstack_s3_client.create_bucket(Bucket=\"autotest-my-bucket\")\n\n    response = await http_client.post(\"/file/\", json={\"filename\": \"test.txt\", \"content\": \"Hello, world!\"})\n    assert response.status_code == 200\n    assert response.json() == {\"key\": \"test.txt\"}\n\n    # Testing on the same level of abstraction and not exposing application's internal implementation details\n    response = await http_client.get(\"/file/test.txt\")\n    assert response.status_code == 200\n    assert response.json() == {\"content\": \"Hello, world!\"}\n</code></pre> <p>Testing business scenarios, not individual application's endpoints</p> <p>This test might violate the principle that one test should test only one thing. However, if we look at the test from the \"end-to-end\" perspective, it tests a single scenario of storing files that provide value to the application users. That's why the term \"end-to-end\" fits well - we're not testing a single HTTP endpoint per test but rather a single user's journey that involves multiple API calls.</p>"},{"location":"getting-started/testing-app-with-backing-services/#creating-test-fixtures","title":"Creating test fixtures","text":"<p>Let's remove the last implementation details from our tests - AWS S3 bucket creation. We'll create a new fixture - <code>_create_s3_buckets</code>. The fixture is session-scoped because we need to create the bucket only once per test session.</p> tests/conftest.py<pre><code>import pytest_asyncio\nfrom types_aiobotocore_s3 import S3Client\n\n\n@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def _create_s3_buckets(localstack_s3_client: S3Client) -&gt; None:\n    await localstack_s3_client.create_bucket(Bucket=\"autotest-my-bucket\")\n</code></pre> <p>The <code>tomodachi_container</code> fixture uses the <code>_create_s3_buckets</code> fixture, so the S3 bucket is created before the application container is started. The S3 bucket creation can be removed from the test code, and now the tests don't even know that the S3 is used as a file store; implementation details are hidden in the fixtures.</p> tests/conftest.py<pre><code>@pytest.fixture(scope=\"session\")\ndef tomodachi_container(\n    testcontainer_image: str,\n    localstack_container: LocalStackContainer,\n    _create_s3_buckets: None,\n) -&gt; Generator[DockerContainer, None, None]:\n    ...\n</code></pre> <p>For completeness, let's add a test for an error-handling scenario when we try to read a file that doesn't exist.</p> tests/test_app.py<pre><code>@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_file_not_found(http_client: httpx.AsyncClient) -&gt; None:\n    response = await http_client.get(\"/file/not-exists.txt\")\n\n    assert response.status_code == 404\n    assert response.json() == {\"error\": \"FILE_NOT_FOUND\"}\n</code></pre>"},{"location":"getting-started/testing-app-with-backing-services/#summary","title":"Summary","text":"<p>In this guide, we tested the application that depends on external backing services like databases or cloud provider services. We tested the application with production-like dependencies to build confidence that it will work the same way in production. By treating backing services as attachable resources, we replaced a dependency on the AWS cloud with the LocalStack container for testing. Also, we run the test suite locally, giving us faster feedback about the changes and improving the development experience, contrary to the tests running only in a deployment pipeline or dedicated test environment. All we need for running tests locally with Testcontainers is a container runtime. Finally, we made the tests robust by testing only the application's public API rather than internal implementation details.</p> <p>The following section explores testing an application that depends on another local or third-party application.</p>"},{"location":"getting-started/testing-app-with-backing-services/#resources","title":"Resources","text":"<ul> <li>https://localstack.cloud</li> <li>https://docs.getmoto.org/en/latest/</li> <li>https://12factor.net/dev-prod-parity</li> <li>https://12factor.net/config</li> <li>https://12factor.net/backing-services</li> </ul>"},{"location":"getting-started/testing-app-with-collaborator-services/","title":"Testing Applications with Collaborator Services","text":"<p>In the previous section, we explored testing applications that depend on backing services like databases or cloud providers. This section focuses on another type of external dependency - collaborator services.</p> <p>A collaborator service is another application or a third-party service that our application directly depends on. They might be developed in-house, running as off-the-shelf software, or a third-party service in an external network. Collaborator services provide a valuable behavior and expose it through an API such as REST. For example, when building a financial system, we might use an external application to obtain currency conversion rates or process credit card payments.</p> <p>In automated testing, it's often not feasible to use the real versions of external applications - they might be slow, expensive, flaky, unreliable, and they might not have a dedicated test environment. If the external application's source code or executable is available, we might launch it in a local testing environment. However, the external app most probably depends on other applications and backing services. Therefore, to test a single application in isolation, we'll end up running a large and complicated environment of many different applications - this is the problem that Testcontainers help avoid.</p>"},{"location":"getting-started/testing-app-with-collaborator-services/#mocking-collaborator-services","title":"Mocking Collaborator Services","text":"<p>During testing as part of the development workflow, we don't want to depend on real versions of external applications because our test environment's complexity will grow, the tests might become flaky, and we won't have any control over the test environment. For example, suppose we want to test that a financial system converts a transaction's currency. The real currency exchange rates change daily, so our financial system's test results will fail every time the new conversion rates are published. To avoid this problem, we must be able to control all variables in the test environment.</p> <p>One solution we'll explore is mocking an external application by creating a fake version of its API that returns predefined data. This way, we'll simulate requests and responses from the external app and be able to test our application in isolation. To mock external APIs, we can use mocking servers: WireMock, MockServer, VCR.py, mountebank, and many more.</p>"},{"location":"getting-started/testing-app-with-collaborator-services/#example-mocking-customer-credit-check-application","title":"Example: Mocking Customer Credit Check Application","text":"<p>Let's create an example order management application. A customer's credit must be verified during a new order creation process. If the customer has good credit, new order creation is allowed. If the credit check fails, the customer can't create new orders until the credit is improved, e.g., by paying all invoices for previous orders. Since credit verification is a complex process, the order management application doesn't implement it; instead, it uses an external app - the customer credit check service.</p> <p></p> <p>We'll use the WireMock HTTP mock server to mock the credit check service's <code>POST /check-credit</code> API. WireMock is an open-source tool for API mock testing. It can help you to create stable test and development environments, isolate yourself from flaky third parties, and simulate APIs that don't exist yet. Tomodachi Testcontainers provides a WireMockContainer and wiremock_container fixture. Used together with Python WireMock SDK, creating API mocks is easy.</p> <p>Warning</p> <p>Since mocks are configured manually, they might not accurately reflect the behavior of a real system. An application tested only with mocks might not work the same in a production environment. Depending on your use case, consider verifying your test doubles against a real system in a separate test suite or adding contract tests. Check out Pact - a tool for contract testing.</p>"},{"location":"getting-started/testing-app-with-collaborator-services/#creating-the-order-management-application","title":"Creating the order management application","text":"<p>The example application has a single endpoint <code>POST /order</code> that expects two <code>string</code> values in the request body: <code>customer_id</code> and <code>product</code>. On successful order creation, the <code>Order</code> object is returned in a response. If the credit check fails, the following errors are returned: <code>CREDIT_CHECK_FAILED</code> or <code>CREDIT_CHECK_UNAVAILABLE</code>.</p> src/app.py<pre><code>import tomodachi\nfrom aiohttp import web\n\nfrom .credit_check import CreditCheckUnavailableError, CustomerCreditCheckFailedError\nfrom .services import create_new_order\n\n\nclass Service(tomodachi.Service):\n    @tomodachi.http(\"POST\", r\"/order/?\")\n    async def http_create_order(self, request: web.Request) -&gt; web.Response:\n        body = await request.json()\n        try:\n            order = await create_new_order(\n                customer_id=body[\"customer_id\"],\n                product=body[\"product\"],\n            )\n            return web.json_response(order.to_dict())\n        except CustomerCreditCheckFailedError:\n            return web.json_response({\"error\": \"CREDIT_CHECK_FAILED\"}, status=400)\n        except CreditCheckUnavailableError:\n            return web.json_response({\"error\": \"CREDIT_CHECK_UNAVAILABLE\"}, status=503)\n</code></pre> <p>The new order creation service creates a new <code>Order</code> object and calls customer credit verification. The order is not stored in a database to keep the example simple.</p> src/services.py<pre><code>import uuid\n\nfrom .credit_check import verify_customer_credit\nfrom .domain import Order\n\n\nasync def create_new_order(customer_id: str, product: str) -&gt; Order:\n    order = Order(\n        id=str(uuid.uuid4()),\n        customer_id=customer_id,\n        product=product,\n    )\n    await verify_customer_credit(order.customer_id)\n    return order\n</code></pre> <p>The <code>Order</code> is a simple <code>dataclass</code> object.</p> src/domain.py<pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Order:\n    id: str\n    customer_id: str\n    product: str\n\n    def to_dict(self) -&gt; dict:\n        return {\n            \"id\": self.id,\n            \"customer_id\": self.customer_id,\n            \"product\": self.product,\n        }\n</code></pre> <p>The <code>verify_customer_credit</code> function calls the external credit check service via HTTP. The URL of the service is configured with the <code>CREDIT_CHECK_SERVICE_URL</code> environment variable. It will help us change the service URL in a test environment. If the response status code is something other than <code>2xx</code>, the <code>CreditCheckUnavailableError</code> is raised. If the credit verification status is not <code>CREDIT_CHECK_PASSED</code>, the <code>CustomerCreditCheckFailedError</code> is raised.</p> src/credit_check.py<pre><code>import os\n\nimport httpx\n\n\nclass CustomerCreditCheckFailedError(Exception):\n    pass\n\n\nclass CreditCheckUnavailableError(Exception):\n    pass\n\n\nasync def verify_customer_credit(customer_id: str) -&gt; None:\n    async with httpx.AsyncClient(base_url=get_credit_check_service_url()) as client:\n        response = await client.post(\n            \"/credit-check\",\n            json={\"customer_id\": customer_id},\n        )\n\n        try:\n            response.raise_for_status()\n        except httpx.HTTPStatusError as e:\n            raise CreditCheckUnavailableError from e\n\n        body = response.json()\n        if body[\"status\"] != \"CREDIT_CHECK_PASSED\":\n            raise CustomerCreditCheckFailedError(customer_id)\n\n\ndef get_credit_check_service_url() -&gt; str:\n    return os.environ[\"CREDIT_CHECK_SERVICE_URL\"]\n</code></pre>"},{"location":"getting-started/testing-app-with-collaborator-services/#configuring-testcontainers","title":"Configuring Testcontainers","text":"<p>To start the <code>WireMockContainer</code>, we'll use the <code>wiremock_container</code> fixture. The credit check service's URL is configured with the <code>CREDIT_CHECK_SERVICE_URL</code> environment variable - it's set to WireMock's URL, so requests for verifying the customer credit will be sent to the WireMock instance running locally in a container.</p> tests/conftest.py<pre><code>from typing import AsyncGenerator, Generator\n\nimport httpx\nimport pytest\nimport pytest_asyncio\n\nfrom tomodachi_testcontainers import DockerContainer, TomodachiContainer, WireMockContainer\n\n\n@pytest.fixture(scope=\"session\")\ndef tomodachi_container(\n    testcontainer_image: str,\n    wiremock_container: WireMockContainer,\n) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        TomodachiContainer(testcontainer_image)\n        .with_env(\"CREDIT_CHECK_SERVICE_URL\", wiremock_container.get_internal_url())\n        .with_command(\"tomodachi run getting_started/orders/app.py --production\")\n    ) as container:\n        yield container\n\n\n@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def http_client(tomodachi_container: TomodachiContainer) -&gt; AsyncGenerator[httpx.AsyncClient, None]:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        yield client\n</code></pre>"},{"location":"getting-started/testing-app-with-collaborator-services/#writing-end-to-end-tests","title":"Writing end-to-end tests","text":"<p>In the first test, we'll test a successful order creation when the customer's credit check passes.</p> <p>Before testing the order management application, we need to configure the <code>POST /check-check</code> API in WireMock. To easily configure WireMock, we'll use Python WireMock SDK. Install it from extras with <code>pip install tomodachi-testcontainers[wiremock]</code> or <code>pip install wiremock</code>. The <code>wiremock_container</code> fixture automatically configures the SDK to communicate with the WireMock server if the WireMock extra is installed.</p> <p>The mock setup code configures WireMock to return JSON body <code>{\"status\": \"CREDIT_CHECK_PASSED\"}</code> when it receives a <code>POST</code> request to the endpoint <code>/credit-check</code>, and the request body is <code>{\"customer_id\": \"123456\"}</code>. After sending the <code>POST /order</code> request to the order service, we receive a successful response indicating that the order has been created. The order service successfully called WireMock, which returned the fake credit check service's response!</p> tests/test_app.py<pre><code>from unittest import mock\n\nimport httpx\nimport pytest\nimport wiremock.client as wm\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_order_created_when_credit_check_passed(http_client: httpx.AsyncClient) -&gt; None:\n    mapping = wm.Mapping(\n        request=wm.MappingRequest(\n            method=wm.HttpMethods.POST,\n            url=\"/credit-check\",\n            body_patterns=[{wm.WireMockMatchers.EQUAL_TO_JSON: {\"customer_id\": \"123456\"}}],\n        ),\n        response=wm.MappingResponse(\n            status=200,\n            json_body={\"status\": \"CREDIT_CHECK_PASSED\"},\n        ),\n    )\n    wm.Mappings.create_mapping(mapping=mapping)\n\n    response = await http_client.post(\n        \"/order\",\n        json={\"customer_id\": \"123456\", \"product\": \"MINIMALIST-SPOON\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"id\": mock.ANY,\n        \"customer_id\": \"123456\",\n        \"product\": \"MINIMALIST-SPOON\",\n    }\n</code></pre> <p>Let's test what happens when a customer's credit check verification fails. We configure the WireMock to respond with JSON body <code>{\"status\": \"CREDIT_CHECK_FAILED\"}</code>. After calling the order management service, we receive the expected <code>HTTP 400</code> and <code>{\"error\": \"CREDIT_CHECK_FAILED\"}</code>.</p> tests/test_app.py<pre><code>@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_order_not_created_when_credit_check_failed(http_client: httpx.AsyncClient) -&gt; None:\n    mapping = wm.Mapping(\n        request=wm.MappingRequest(\n            method=wm.HttpMethods.POST,\n            url=\"/credit-check\",\n            body_patterns=[{wm.WireMockMatchers.EQUAL_TO_JSON: {\"customer_id\": \"123456\"}}],\n        ),\n        response=wm.MappingResponse(\n            status=200,\n            json_body={\"status\": \"CREDIT_CHECK_FAILED\"},\n        ),\n    )\n    wm.Mappings.create_mapping(mapping=mapping)\n\n    response = await http_client.post(\n        \"/order\",\n        json={\"customer_id\": \"123456\", \"product\": \"MINIMALIST-SPOON\"},\n    )\n\n    assert response.status_code == 400\n    assert response.json() == {\"error\": \"CREDIT_CHECK_FAILED\"}\n</code></pre> <p>The last example tests the scenario when the credit verification service responds with an <code>Internal Server Error</code>. This error scenario is very hard to simulate when testing with a real version of the external application. Using mocks, you control the environment and its behavior. In this test, the WireMock is configured to return <code>HTTP 500</code> with the <code>Internal Server Error</code> response; the order management service returns <code>HTTP 503</code> and <code>{\"error\": \"CREDIT_CHECK_UNAVAILABLE\"}</code>.</p> tests/test_app.py<pre><code>@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_order_not_created_when_credit_check_service_unavailable(http_client: httpx.AsyncClient) -&gt; None:\n    mapping = wm.Mapping(\n        request=wm.MappingRequest(method=wm.HttpMethods.POST, url=\"/credit-check\"),\n        response=wm.MappingResponse(\n            status=500,\n            body=\"Internal Server Error\",\n        ),\n    )\n    wm.Mappings.create_mapping(mapping=mapping)\n\n    response = await http_client.post(\n        \"/order\",\n        json={\"customer_id\": \"123456\", \"product\": \"MINIMALIST-SPOON\"},\n    )\n\n    assert response.status_code == 503\n    assert response.json() == {\"error\": \"CREDIT_CHECK_UNAVAILABLE\"}\n</code></pre>"},{"location":"getting-started/testing-app-with-collaborator-services/#extracting-mock-setup-functions","title":"Extracting mock setup functions","text":"<p>Setting up the mocks requires lengthy boilerplate code, even for these simple examples. In the real scenario, the API mock setup will be tens of code lines configuring nested request/response data structures. It's a good idea to extract mock setup code to separate functions and modules.</p> tests/credit_check_mocks.py<pre><code>import wiremock.client as wm\n\n\ndef customer_credit_check_passes(customer_id: str) -&gt; None:\n    mapping = wm.Mapping(\n        request=wm.MappingRequest(\n            method=wm.HttpMethods.POST,\n            url=\"/credit-check\",\n            body_patterns=[{wm.WireMockMatchers.EQUAL_TO_JSON: {\"customer_id\": customer_id}}],\n        ),\n        response=wm.MappingResponse(\n            status=200,\n            json_body={\"status\": \"CREDIT_CHECK_PASSED\"},\n        ),\n    )\n    wm.Mappings.create_mapping(mapping=mapping)\n\n\ndef customer_credit_check_fails(customer_id: str) -&gt; None:\n    mapping = wm.Mapping(\n        request=wm.MappingRequest(\n            method=wm.HttpMethods.POST,\n            url=\"/credit-check\",\n            body_patterns=[{wm.WireMockMatchers.EQUAL_TO_JSON: {\"customer_id\": customer_id}}],\n        ),\n        response=wm.MappingResponse(\n            status=200,\n            json_body={\"status\": \"CREDIT_CHECK_FAILED\"},\n        ),\n    )\n    wm.Mappings.create_mapping(mapping=mapping)\n\n\ndef customer_credit_check_returns_internal_server_error() -&gt; None:\n    mapping = wm.Mapping(\n        request=wm.MappingRequest(method=wm.HttpMethods.POST, url=\"/credit-check\"),\n        response=wm.MappingResponse(\n            status=500,\n            body=\"Internal Server Error\",\n        ),\n    )\n    wm.Mappings.create_mapping(mapping=mapping)\n</code></pre> <p>Now, the tests are shorter and better express their intent. To isolate tests, we can use the <code>reset_wiremock_container_on_teardown</code> fixture to delete all WireMock stub mappings between tests. It ensures that all tests explicitly configure API mocks for their test scenario and don't depend on mocks configured in previously executed tests.</p> tests/test_app.py<pre><code>from unittest import mock\n\nimport httpx\nimport pytest\n\nfrom . import credit_check_mocks\n\npytestmark = pytest.mark.usefixtures(\"reset_wiremock_container_on_teardown\")\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_order_created_when_credit_check_passed(http_client: httpx.AsyncClient) -&gt; None:\n    customer_id = \"123456\"\n    credit_check_mocks.customer_credit_check_passes(customer_id)\n\n    response = await http_client.post(\n        \"/order\",\n        json={\"customer_id\": customer_id, \"product\": \"MINIMALIST-SPOON\"},\n    )\n\n    assert response.status_code == 200\n    assert response.json() == {\n        \"id\": mock.ANY,\n        \"customer_id\": customer_id,\n        \"product\": \"MINIMALIST-SPOON\",\n    }\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_order_not_created_when_credit_check_failed(http_client: httpx.AsyncClient) -&gt; None:\n    customer_id = \"123456\"\n    credit_check_mocks.customer_credit_check_fails(customer_id)\n\n    response = await http_client.post(\n        \"/order\",\n        json={\"customer_id\": customer_id, \"product\": \"MINIMALIST-SPOON\"},\n    )\n\n    assert response.status_code == 400\n    assert response.json() == {\"error\": \"CREDIT_CHECK_FAILED\"}\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_order_not_created_when_credit_check_service_unavailable(http_client: httpx.AsyncClient) -&gt; None:\n    credit_check_mocks.customer_credit_check_returns_internal_server_error()\n\n    response = await http_client.post(\n        \"/order\",\n        json={\"customer_id\": \"123456\", \"product\": \"MINIMALIST-SPOON\"},\n    )\n\n    assert response.status_code == 503\n    assert response.json() == {\"error\": \"CREDIT_CHECK_UNAVAILABLE\"}\n</code></pre>"},{"location":"getting-started/testing-app-with-collaborator-services/#summary","title":"Summary","text":"<p>In this guide, we tested an application that directly depends on another system's API. Often, it's not feasible to test the application with the real versions of its dependencies, so API mocking tools like WireMock allow us to isolate our automated test environments by faking external systems. Mocks are a powerful tool because they allow us to control all variables in the test environment. Using mocks, we can simulate different external system's behaviors and error-handling scenarios, which might be hard or impossible to test with a real version of an external system.</p> <p>However, since mocks are configured manually, they don't guarantee that the external system behaves the same in the production environment. To ensure that mocks are accurate, consider adding a separate test suite for verifying mocks with a real system or adding contract tests with tools like Pact.</p>"},{"location":"getting-started/testing-app-with-collaborator-services/#resources","title":"Resources","text":"<ul> <li>https://pythonspeed.com/articles/verified-fakes/</li> <li>https://martinfowler.com/bliki/ContractTest.html</li> <li>https://pact.io/</li> <li>https://wiremock.org/</li> <li>https://www.mock-server.com/</li> <li>https://vcrpy.readthedocs.io/en/latest/</li> <li>https://www.mbtest.org/</li> </ul>"},{"location":"getting-started/testing-asynchronous-systems/","title":"Testing Asynchronous Systems","text":"<p>In the previous section, we tested an application that directly depends on another application's HTTP API; we mocked its public API with an HTTP mock server. This section will explore another scenario - testing an application that depends on other services through asynchronous message bus.</p>"},{"location":"getting-started/testing-asynchronous-systems/#example-event-driven-customer-management-application","title":"Example: Event-Driven Customer Management Application","text":"<p>Let's test an example Customer Management Application. A user can create a new account in the Customer application and place new orders in the Order application. The Customer and Order apps communicate through an asynchronous message bus, in this example, AWS SNS/SQS. When the customer creates a new account, the Customer app publishes a <code>CustomerCreated</code> event to the message bus. When the customer creates a new order, the Order app publishes an <code>OrderCreated</code> event to the message bus. The Customer application listens for <code>OrderCreated</code> events and saves a list of orders that belong to the customer.</p> <p>The apps communicate indirectly through the message bus</p> <p>A message bus is a decoupling point. The Customer and Order apps communicate indirectly through the message bus. To test the Customer app in isolation, we don't need to run a real or mocked version of the Order app - We only need to publish the Order app's events to the message bus to simulate interactions with the Customer app.</p> <p></p>"},{"location":"getting-started/testing-asynchronous-systems/#creating-the-customer-management-application","title":"Creating the customer management application","text":"<p>Let's first create the example Customer application.</p> <p>Note</p> <p>Since this example involves setting up many dependencies like AWS DynamoDB and AWS SNS/SQS, the setup code is omitted for brevity. Find the complete example's code in GitHub.</p> <p>The app has three endpoints:</p> <ul> <li>HTTP <code>POST /customer</code> - for new customer creation, publishes <code>CustomerCreatedEvent</code> to AWS SNS.</li> <li>HTTP <code>GET /customer/&lt;id&gt;</code> - for querying existing customers.</li> <li>AWS SQS consumer listening for <code>OrderCreatedEvents</code> - saves the received Order identifier on an existing customer's object.</li> </ul> src/app.py<pre><code>class Service(tomodachi.Service):\n    ...\n\n    @tomodachi.http(\"POST\", r\"/customer/?\")\n    async def create_customer(self, request: web.Request) -&gt; web.Response:\n        data = await request.json()\n        customer = Customer(\n            customer_id=str(uuid.uuid4()),\n            name=data[\"name\"],\n            orders=[],\n        )\n        event = CustomerCreatedEvent.from_customer(customer)\n        await self._repository.create(customer)\n        await tomodachi.aws_sns_sqs_publish(\n            self,\n            data=event.to_dict(),\n            topic=\"customer--created\",\n            message_envelope=JsonBase,\n        )\n        return web.json_response(customer.to_dict())\n\n    @tomodachi.http(\"GET\", r\"/customer/(?P&lt;customer_id&gt;[^/]+?)/?\")\n    async def get_customer(self, request: web.Request, customer_id: str) -&gt; web.Response:\n        customer = await self._repository.get(customer_id)\n        if not customer:\n            return web.json_response({\"error\": \"CUSTOMER_NOT_FOUND\"}, status=404)\n        return web.json_response(customer.to_dict())\n\n    @tomodachi.aws_sns_sqs(\n        \"order--created\",\n        queue_name=\"customer--order-created\",\n        dead_letter_queue_name=\"customer--order-created--dlq\",\n        max_receive_count=int(os.getenv(\"AWS_SQS_MAX_RECEIVE_COUNT\", 3)),\n        message_envelope=JsonBase,\n        visibility_timeout=int(os.getenv(\"AWS_SQS_VISIBILITY_TIMEOUT\", 30)),\n    )\n    async def handle_order_created(self, data: dict) -&gt; None:\n        try:\n            event = OrderCreatedEvent.from_dict(data)\n            await self._repository.add_order(event)\n        except Exception as e:\n            raise AWSSNSSQSInternalServiceError from e\n</code></pre>"},{"location":"getting-started/testing-asynchronous-systems/#configuring-testcontainers","title":"Configuring Testcontainers","text":"<p>The Testcontainer's configuration in this example is involved because we must configure two infrastructure dependencies - AWS DynamoDB and AWS SNS/SQS.</p> <ul> <li> <p>The fixture <code>_create_topics_and_queues</code> creates necessary pub/sub topics and queues   for the Customer and Order app to communicate through the AWS SNS/SQS message bus.</p> </li> <li> <p>The fixture <code>_purge_queues_on_teardown</code> deletes all messages from the queues after every test to ensure test isolation - that messages   don't leak between tests.</p> </li> <li> <p>The <code>tomodachi_container</code> fixture uses <code>LocalStackContainer</code> to emulate AWS DynamoDB and AWS SNS/SQS - in the same way as in the   Testing Applications with Backing Services guide.   The <code>TomodachiContainer</code> is configured with the LocalStack container's environment variables.   The <code>_create_topics_and_queues</code> fixture is used in the <code>tomodachi_container</code> fixture to ensure that topics and queues   are created before the Customer application starts.</p> </li> </ul> tests/conftest.py<pre><code>from typing import AsyncGenerator, Generator\n\nimport httpx\nimport pytest\nimport pytest_asyncio\n\nfrom tomodachi_testcontainers import DockerContainer, LocalStackContainer, TomodachiContainer\nfrom tomodachi_testcontainers.clients import SNSSQSTestClient\n\n\n@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def _create_topics_and_queues(localstack_snssqs_tc: SNSSQSTestClient) -&gt; None:\n    await localstack_snssqs_tc.subscribe_to(topic=\"customer--created\", queue=\"customer--created\")\n    await localstack_snssqs_tc.subscribe_to(topic=\"order--created\", queue=\"customer--order-created\")\n\n\n@pytest_asyncio.fixture(loop_scope=\"session\", autouse=True)\nasync def _purge_queues_on_teardown(localstack_snssqs_tc: SNSSQSTestClient) -&gt; AsyncGenerator[None, None]:\n    yield\n    await localstack_snssqs_tc.purge_queue(\"customer--created\")\n    await localstack_snssqs_tc.purge_queue(\"customer--order-created\")\n\n\n@pytest.fixture(scope=\"session\")\ndef tomodachi_container(\n    testcontainer_image: str,\n    localstack_container: LocalStackContainer,\n    _create_topics_and_queues: None,\n) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        TomodachiContainer(testcontainer_image)\n        .with_env(\"AWS_REGION\", \"us-east-1\")\n        .with_env(\"AWS_ACCESS_KEY_ID\", \"testing\")\n        .with_env(\"AWS_SECRET_ACCESS_KEY\", \"testing\")\n        .with_env(\"AWS_SQS_MAX_RECEIVE_COUNT\", \"1\")\n        .with_env(\"AWS_SQS_VISIBILITY_TIMEOUT\", \"3\")\n        .with_env(\"AWS_SNS_ENDPOINT_URL\", localstack_container.get_internal_url())\n        .with_env(\"AWS_SQS_ENDPOINT_URL\", localstack_container.get_internal_url())\n        .with_env(\"AWS_DYNAMODB_ENDPOINT_URL\", localstack_container.get_internal_url())\n        .with_env(\"DYNAMODB_TABLE_NAME\", \"autotest-customers\")\n        .with_command(\"tomodachi run getting_started/customers/app.py --production\")\n    ) as container:\n        yield container\n\n\n@pytest_asyncio.fixture(scope=\"module\", loop_scope=\"session\")\nasync def http_client(tomodachi_container: TomodachiContainer) -&gt; AsyncGenerator[httpx.AsyncClient, None]:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        yield client\n</code></pre>"},{"location":"getting-started/testing-asynchronous-systems/#testing-for-published-messages","title":"Testing for published messages","text":"<p>Let's test the first scenario - a customer creates a new account by calling the <code>POST /customer</code> endpoint, and a new <code>CustomerCreatedEvent</code> is published to notify surrounding systems that a new customer has registered.</p> <p>First, the test calls the <code>POST /customer</code> endpoint and creates a new customer. To test that the <code>CustomerCreatedEvent</code> has been published, the test attempts to retrieve a message from the <code>customer--created</code> queue using the <code>SNSSQSTestClient</code> provided by Tomodachi Testcontainers for easier testing of AWS SNS/SQS pub/sub with the Tomodachi framework. The <code>SNSSQSTestClient</code> is accessed with the <code>localstack_snssqs_tc</code> fixture.</p> <p>Danger</p> <p>This test has a problem - since the message bus is asynchronous, it's not guaranteed that the <code>CustomerCreatedEvent</code> will be immediately visible to consumers. It takes some time from the moment the message is published until it's visible to consumers. Therefore, this test is flaky - no messages might be visible yet, so the test can randomly fail.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\nfrom tomodachi.envelope.json_base import JsonBase\n\nfrom tomodachi_testcontainers.clients import SNSSQSTestClient\n\n\n@pytest.mark.xfail(reason=\"CustomerCreatedEvent is emitted asynchronously\")\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_created_event_emitted(\n    http_client: httpx.AsyncClient,\n    localstack_snssqs_tc: SNSSQSTestClient,\n) -&gt; None:\n    # Act\n    response = await http_client.post(\"/customer\", json={\"name\": \"John Doe\"})\n    body = response.json()\n    customer_id = body[\"customer_id\"]\n    assert response.status_code == 200\n\n    # Assert\n    events = await localstack_snssqs_tc.receive(\"customer--created\", JsonBase, dict[str, str])\n    assert len(events) == 1\n    assert events[0].payload == {\n        \"customer_id\": customer_id,\n        \"name\": \"John Doe\",\n    }\n</code></pre> <p>To fix the test, we need to wait until the message becomes visible. The easiest solution is to sleep for a fixed time between the customer creation and the attempt to receive the message.</p> <p>Danger</p> <p>This approach works; however, tests will become slow on a larger scale due to unnecessary waiting. For example, in a test suite of 60 test cases, there'll be an additional 60 seconds of waiting.</p> tests/test_app.py<pre><code>import asyncio\n\nimport httpx\nimport pytest\nfrom tomodachi.envelope.json_base import JsonBase\n\nfrom tomodachi_testcontainers.clients import SNSSQSTestClient\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_created_event_emitted(\n    http_client: httpx.AsyncClient,\n    localstack_snssqs_tc: SNSSQSTestClient,\n) -&gt; None:\n    # Act\n    response = await http_client.post(\"/customer\", json={\"name\": \"John Doe\"})\n    body = response.json()\n    customer_id = body[\"customer_id\"]\n    assert response.status_code == 200\n\n    # Assert\n    await asyncio.sleep(1)  # Wait for the message to become visible to consumers\n\n    events = await localstack_snssqs_tc.receive(\"customer--created\", JsonBase, dict[str, str])\n    assert len(events) == 1\n    assert events[0].payload == {\n        \"customer_id\": customer_id,\n        \"name\": \"John Doe\",\n    }\n</code></pre>"},{"location":"getting-started/testing-asynchronous-systems/#using-asynchronous-probing-for-testing-asynchronous-systems","title":"Using Asynchronous Probing for testing asynchronous systems","text":"<p>Using asynchronous probing (sampling) is better than sleeping for a fixed time. The idea of asynchronous probing is continuously testing for a condition in short time intervals.</p> <p>Tomodachi Testcontainers provides a <code>probe_until</code> function for asynchronous probing. The <code>probe_until</code> receives a probe function. The probe is continuously invoked in <code>probe_interval</code> (defaults to <code>0.1 second</code>) until it finishes without exceptions. When the <code>stop_after</code> timeout is reached (defaults to <code>3.0</code> seconds), the probing is stopped, and the last probe's exception is raised.</p> <p>In our test, we define the probe function - <code>_customer_created_event_emitted</code>. The probe reads messages from the SQS queue and expects to find one message. If no messages are returned, the probe will fail with <code>ValueError</code> and will be retried in <code>probe_interval</code>. When the probe receives one message from the SQS queue, it's returned from the probe to the main test body.</p> <p>Note</p> <p>A probe must contain an assertion, e.g., a check that exactly one message is received from the queue. In this example, the assertion is the list unpacking operation <code>[event] = localstack_snssqs_tc.receive(...)</code>. It could also be <code>events = localstack_snssqs_tc.receive(...); assert len(events) == 1</code>.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\nfrom tomodachi.envelope.json_base import JsonBase\n\nfrom tomodachi_testcontainers.async_probes import probe_until\nfrom tomodachi_testcontainers.clients import SNSSQSTestClient\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_created_event_emitted(\n    http_client: httpx.AsyncClient,\n    localstack_snssqs_tc: SNSSQSTestClient,\n) -&gt; None:\n    # Act\n    response = await http_client.post(\"/customer\", json={\"name\": \"John Doe\"})\n    body = response.json()\n    customer_id = body[\"customer_id\"]\n\n    # Assert\n    async def _customer_created_event_emitted() -&gt; dict[str, str]:\n        [event] = await localstack_snssqs_tc.receive(\"customer--created\", JsonBase, dict[str, str])\n        return event.payload\n\n    event = await probe_until(_customer_created_event_emitted, probe_interval=0.1, stop_after=3.0)\n    assert event == {\n        \"customer_id\": customer_id,\n        \"name\": \"John Doe\",\n    }\n</code></pre> <p>Asynchronous probing reduces wait time</p> <p>The benefit of asynchronous probing is minimal wait time - as soon as the message is received, the test stops waiting. This way, we ensure fast test runtime.</p> <p>The <code>probe_until</code> is inspired by Awaitility and busypie - read more about testing asynchronous systems in their documentation.</p>"},{"location":"getting-started/testing-asynchronous-systems/#probing-for-no-visible-effect","title":"Probing for no visible effect","text":"<p>Sometimes, we'd like to test that a system doesn't publish a specific message. For example, let's test that a message consumer implements the idempotent consumer pattern - it performs an operation only once and discards duplicate messages.</p> <p>There are several ways to test this:</p> <ul> <li>Publish two duplicate messages and probe that exactly one outcome message has been published.</li> <li>Publish a single message and assert that an outcome message has been published. Then, publish the duplicate   message and <code>probe_during_interval</code>   that the outcome message is not published for, e.g., <code>3</code> seconds.</li> </ul> <p>The downside of the second approach is that it introduces extra wait time for the tests; however, sometimes, it's a helpful technique.</p>"},{"location":"getting-started/testing-asynchronous-systems/#testing-asynchronous-message-consumers","title":"Testing asynchronous message consumers","text":"<p>Let's test that our Customer app consumes <code>OrderCreatedEvents</code> and associates new orders with existing customers.</p> <ul> <li> <p>In the <code>arrange</code> step, we create a new customer.</p> </li> <li> <p>Then, in the <code>act</code> step, we publish two SNS messages to the <code>order--created</code> topic with predefined order identifiers.</p> </li> <li> <p>In the <code>assert</code> step, we probe the <code>GET /customer/&lt;id&gt;</code> API until two messages are consumed - the two orders are associated with the customer.</p> </li> </ul> <p>Since the message consumer (Customer app) is asynchronous, it takes time for messages to be picked up and processed. Therefore, using asynchronous probing, we continuously check the system's state until all published messages are consumed.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\nfrom tomodachi.envelope.json_base import JsonBase\n\nfrom tomodachi_testcontainers.async_probes import probe_until\nfrom tomodachi_testcontainers.clients import SNSSQSTestClient\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_register_created_order(\n    http_client: httpx.AsyncClient,\n    localstack_snssqs_tc: SNSSQSTestClient,\n) -&gt; None:\n    # Arrange\n    response = await http_client.post(\"/customer\", json={\"name\": \"John Doe\"})\n    customer_id = response.json()[\"customer_id\"]\n    assert response.status_code == 200\n\n    # Act\n    order_ids = [\"6c403295-2755-4178-a4f1-e3b698927971\", \"c8bb390a-71f4-4e8f-8879-c92261b0e18e\"]\n    for order_id in order_ids:\n        await localstack_snssqs_tc.publish(\n            topic=\"order--created\",\n            data={\"order_id\": order_id, \"customer_id\": customer_id},\n            envelope=JsonBase,\n        )\n\n    # Assert\n    async def _new_orders_associated_with_customer() -&gt; None:\n        response = await http_client.get(f\"/customer/{customer_id}\")\n\n        assert response.status_code == 200\n        assert response.json() == {\n            \"customer_id\": customer_id,\n            \"name\": \"John Doe\",\n            \"orders\": [\n                {\"order_id\": order_ids[0]},\n                {\"order_id\": order_ids[1]},\n            ],\n        }\n\n    await probe_until(_new_orders_associated_with_customer)\n</code></pre>"},{"location":"getting-started/testing-asynchronous-systems/#testing-error-handling-with-dead-letter-queues","title":"Testing error-handling with dead-letter queues","text":"<p>When a consumer cannot process a message, it's a good practice to move it to a dead-letter queue (DLQ) for further troubleshooting. Otherwise, a faulty message can be lost or retried forever.</p> <p>The <code>handle_order_created</code> message consumer is configured to move faulty messages to the <code>customer--order-created--dlq</code> DLQ. In Tomodachi framework, it's necessary to raise the <code>AWSSNSSQSInternalServiceError</code> to retry a message; otherwise, it's deleted from a queue.</p> <p>In AWS SQS, the <code>visibility_timeout</code> specifies when a consumed message becomes visible again to other consumers. By default, it's <code>30 seconds</code>, so our test would have to wait <code>30 seconds</code> to receive a message from the DLQ - it's too long for a single test. To speed up the test, in the autotest environment, we set the environment variable <code>AWS_SQS_VISIBILITY_TIMEOUT</code> to something smaller, e.g., <code>3 seconds</code>, and decrease number of retries to <code>1</code> with the <code>AWS_SQS_MAX_RECEIVE_COUNT</code> environment variable. The setting should be no less than the default <code>30 seconds</code> in a production environment.</p> src/app.py<pre><code>class Service(tomodachi.Service):\n    ...\n\n    @tomodachi.aws_sns_sqs(\n        \"order--created\",\n        queue_name=\"customer--order-created\",\n        dead_letter_queue_name=\"customer--order-created--dlq\",\n        max_receive_count=int(os.getenv(\"AWS_SQS_MAX_RECEIVE_COUNT\", 3)),\n        message_envelope=JsonBase,\n        visibility_timeout=int(os.getenv(\"AWS_SQS_VISIBILITY_TIMEOUT\", 30)),\n    )\n    async def handle_order_created(self, data: dict) -&gt; None:\n        try:\n            event = OrderCreatedEvent.from_dict(data)\n            await self._repository.add_order(event)\n        except Exception as e:\n            raise AWSSNSSQSInternalServiceError from e\n</code></pre> <p>Let's test that the <code>OrderCreatedEvent</code> message is moved to the DLQ if the given <code>customer_id</code> is not found in the customer's database. Due to message retries and <code>visibility_timeout</code>, we set the async probe's <code>stop_after</code> value to a higher value, e.g., <code>10 seconds</code>.</p> tests/test_app.py<pre><code>import uuid\n\nimport pytest\nfrom tomodachi.envelope.json_base import JsonBase\n\nfrom tomodachi_testcontainers.async_probes import probe_until\nfrom tomodachi_testcontainers.clients import SNSSQSTestClient\n\n\n@pytest.mark.usefixtures(\"tomodachi_container\")\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_not_found_for_newly_created_order(localstack_snssqs_tc: SNSSQSTestClient) -&gt; None:\n    # Arrange\n    customer_id = str(uuid.uuid4())\n    order_id = str(uuid.uuid4())\n\n    # Act\n    await localstack_snssqs_tc.publish(\n        topic=\"order--created\",\n        data={\"order_id\": order_id, \"customer_id\": customer_id},\n        envelope=JsonBase,\n    )\n\n    # Assert\n    async def _order_created_event_moved_to_dlq() -&gt; dict[str, str]:\n        [event] = await localstack_snssqs_tc.receive(\"customer--order-created--dlq\", JsonBase, dict[str, str])\n        return event.payload\n\n    event = await probe_until(_order_created_event_moved_to_dlq, stop_after=10.0)\n    assert event == {\"order_id\": order_id, \"customer_id\": customer_id}\n</code></pre>"},{"location":"getting-started/testing-asynchronous-systems/#other-application-tests","title":"Other application tests","text":"<p>For completeness, let's add the customer application's HTTP endpoint tests.</p> tests/test_app.py<pre><code>import uuid\nfrom unittest import mock\n\nimport httpx\nimport pytest\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_not_found(http_client: httpx.AsyncClient) -&gt; None:\n    customer_id = uuid.uuid4()\n    response = await http_client.get(f\"/customer/{customer_id}\")\n\n    assert response.status_code == 404\n    assert response.json() == {\"error\": \"CUSTOMER_NOT_FOUND\"}\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_created_and_get_customer(http_client: httpx.AsyncClient) -&gt; None:\n    response = await http_client.post(\"/customer\", json={\"name\": \"John Doe\"})\n    body = response.json()\n    customer_id = body[\"customer_id\"]\n    assert response.status_code == 200\n    assert body == {\n        \"customer_id\": mock.ANY,\n        \"name\": \"John Doe\",\n        \"orders\": [],\n    }\n\n    response = await http_client.get(f\"/customer/{customer_id}\")\n    assert response.status_code == 200\n    assert response.json() == {\n        \"customer_id\": customer_id,\n        \"name\": \"John Doe\",\n        \"orders\": [],\n    }\n</code></pre>"},{"location":"getting-started/testing-asynchronous-systems/#summary","title":"Summary","text":"<p>Testing asynchronous systems might initially seem complicated due to a different programming and mental mode - operations are not performed immediately; they need to be awaited. However, testing applications that communicate with other systems through an asynchronous message bus is pretty simple because the message bus decouples the applications from each other. To test an app in isolation, we should publish messages in the correct format to the message bus and wait until the app consumes them and changes its state. There's no need to configure additional mocks or external apps. The asynchronous probing technique makes awaiting asynchronous operations easy and fast - it continuously probes the application for a state change.</p> <p>As with testing apps that communicate with other systems with synchronous APIs (Testing Applications with Collaborator Services), we can't be sure that the same message format is used in production as we're using for testing. It might be necessary to add additional contract tests to ensure the correctness of the test message format. Pact, a contract testing tool, supports testing contracts in event-driven systems.</p>"},{"location":"getting-started/testing-asynchronous-systems/#references","title":"References","text":"<ul> <li>https://aws.amazon.com/sns/</li> <li>https://en.wikipedia.org/wiki/Publish-subscribe_pattern</li> <li>http://www.awaitility.org/</li> <li>https://github.com/rockem/busypie</li> <li>https://github.com/kalaspuff/tomodachi</li> <li>https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html</li> <li>https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html</li> <li>https://docs.pact.io/implementation_guides/javascript/docs/messages</li> </ul>"},{"location":"getting-started/testing-cronjobs-and-scripts/","title":"Testing Cronjobs and Scripts","text":"<p>TODO</p>"},{"location":"getting-started/testing-simple-app/","title":"Testing Simple Application","text":""},{"location":"getting-started/testing-simple-app/#creating-a-simple-web-application","title":"Creating a simple web application","text":"<p>Let's start with a simple <code>hello, world</code> web application. The app has one endpoint, <code>GET /hello</code>, that greets you with a name given in a query parameter.</p> src/app.py<pre><code>import tomodachi\nfrom aiohttp import web\n\n\nclass Service(tomodachi.Service):\n    @tomodachi.http(\"GET\", r\"/hello/?\")\n    async def hello(self, request: web.Request) -&gt; web.Response:\n        name = request.query.get(\"name\", \"world\")\n        return web.json_response({\"message\": f\"Hello, {name}!\"})\n</code></pre> <p>We want to test that the application behaves as expected and all its components are configured correctly - framework, Docker container, and dependencies. We can do that with an end-to-end (E2E) test that starts the application as a Docker container, sends an HTTP request, and asserts that the response is correct.</p>"},{"location":"getting-started/testing-simple-app/#creating-a-first-testcontainer","title":"Creating a first Testcontainer","text":"<p>Before writing the test, we need to start the application in a Docker container. \ud83d\udc33</p> tests/conftest.py<pre><code>from typing import Generator\n\nimport pytest\n\nfrom tomodachi_testcontainers import DockerContainer, TomodachiContainer\n\n\n@pytest.fixture(scope=\"session\")\ndef tomodachi_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with TomodachiContainer(testcontainer_image).with_command(\n        \"tomodachi run getting_started/hello/app.py --production\"\n    ) as container:\n        yield container\n</code></pre> <p>The <code>testcontainer_image</code> fixture builds the Docker image with a Dockerfile from the current working directory, and removes the Docker image when all tests finish.</p> <p>The <code>TomodachiContainer</code> receives the built image ID and starts the Testcontainer in a context manager on a random available port. The context manager deletes the Testcontainer on exit.</p> <p>The <code>tomodachi_container</code> fixture is assigned the <code>session</code> scope to create the container only once per test session. It's a good practice to create Testcontainers only once for better performance - it takes some time for a Docker container to start, and the test suite will be slow if containers are recreated for every test.</p>"},{"location":"getting-started/testing-simple-app/#writing-end-to-end-tests","title":"Writing end-to-end tests","text":"<p>Having the <code>tomodachi_container</code> fixture, we can write the first end-to-end test. Let's test that the application greets us with <code>Hello, Testcontainers!</code> when we provide the <code>?name=Testcontainers</code> parameter.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\n\nfrom tomodachi_testcontainers import TomodachiContainer\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hello_testcontainers(tomodachi_container: TomodachiContainer) -&gt; None:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        response = await client.get(\"/hello\", params={\"name\": \"Testcontainers\"})\n\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, Testcontainers!\"}\n</code></pre> <p>The test configures the httpx HTTP client with the Testcontainer's base URL. The <code>tomodachi_container.get_external_url()</code> returns a URL for accessing the Docker container from the host machine in a format like <code>http://localhost:1234</code> (the port is assigned randomly). Finally, we send the <code>GET /hello?name=Testcontainers</code> request and assert that we received the expected response. That's it! We ensured that our application started, all its components were configured correctly and worked as expected.</p> <p>Let's test the default case when the <code>name</code> query parameter is not provided.</p> tests/test_app.py<pre><code>@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hello_world(tomodachi_container: TomodachiContainer) -&gt; None:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        response = await client.get(\"/hello\")\n\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, world!\"}\n</code></pre> <p>End-to-end or integration test?</p> <p>What's the difference between end-to-end and integration tests? It depends on the context where the tests are written and what they are testing. Often, the term end-to-end test is used when talking about tests that test the behavior of multiple applications working together to achieve some valuable outcome. Usually, such tests are developed in a separate code repository and run in a staging environment, not on the developer's local computer. The term integration test can refer to tests that exercise a subset of the whole system, e.g., two applications working together. Also, it can be used when referring to testing that a single application's internal components are working together correctly.</p> <p>In the context of Testcontainers, we're creating isolated tests for a single application that runs in a controlled environment. An application consists of multiple sub-components: framework, runtime environment like OS in a Docker container, programming language dependencies, third-party packages, etc. Testing that all components are configured correctly and working together gives you immediate feedback and eases future maintenance - having such tests helps upgrade dependencies effortlessly, which is necessary for keeping your system secure. Also, we want to test the application's behavior to ensure it delivers the desired outcome. So, apart from testing that the application works, we'll verify that it does the right thing.</p> <p>Therefore, when testing a single application in isolation, the difference between end-to-end and integration tests is fuzzy. I'll stick with the end-to-end tests because they better describe the tests we're writing in these guides - the tests that exercise the application's public API end-to-end, sending requests and asserting the responses.</p> <p>There are no ultimately correct terms - select the one that makes the most sense in your context and problem domain, and stick with it; it might be something entirely different.</p>"},{"location":"getting-started/testing-simple-app/#creating-test-fixtures","title":"Creating test fixtures","text":"<p>You might have noticed a duplication in how we configure the <code>httpx.AsyncClient</code> in every test. It calls for a new fixture. Let's create the <code>http_client</code> fixture and refactor the tests.</p> tests/conftest.py<pre><code>from typing import AsyncGenerator\n\nimport httpx\nimport pytest_asyncio\n\n\n@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def http_client(tomodachi_container: TomodachiContainer) -&gt; AsyncGenerator[httpx.AsyncClient, None]:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        yield client\n</code></pre> <p>Now, tests are using the <code>http_client</code> fixture.</p> tests/test_app.py<pre><code>import httpx\nimport pytest\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hello_testcontainers(http_client: httpx.AsyncClient) -&gt; None:\n    response = await http_client.get(\"/hello\", params={\"name\": \"Testcontainers\"})\n\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, Testcontainers!\"}\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_hello_world(http_client: httpx.AsyncClient) -&gt; None:\n    response = await http_client.get(\"/hello\")\n\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello, world!\"}\n</code></pre> <p>The code is a little bit cleaner. A problem with end-to-end tests is that the code can get lengthy as we create more complex test cases. It's due to the accidental complexity of the high-level protocols and concepts we're working with, e.g., calling HTTP endpoints requires setup and boilerplate code. To keep the tests clean, it's important to notice such duplications and complexities and refactor the code with fixtures and helper functions.</p>"},{"location":"getting-started/testing-simple-app/#summary","title":"Summary","text":"<p>That's it for the first example! \ud83c\udf89</p> <p>We've learned how to launch an application in a temporary Docker container and interact with it from the test suite. However, unlike the app in this example, most applications don't exist in isolation. They depend on other applications or infrastructure components like databases, file stores, cloud provider services, etc.</p> <p>In the next section, we'll see how to locally test an application with its external dependencies without deploying it to a real environment.</p>"},{"location":"guides/","title":"Guides","text":"<p>The guides describe more advanced and focused testing approaches with Testcontainers and beyond.</p> <p>Info</p> <p>See the Getting Started section if you're just getting started.</p>"},{"location":"guides/creating-app-facade/","title":"Refactoring Complex Tests with Facade Pattern","text":"<p>TODO</p>"},{"location":"guides/creating-new-testcontainers/","title":"Creating new Testcontainers","text":"<p>Creating a new Testcontainer is not harder than writing a <code>docker run</code> command. Testcontainers library API minimizes the amount of boilerplate code.</p> <p>This guide will use the <code>HTTPBin</code> application as an example for creating new Testcontainers. <code>HTTPBin</code> is a simple HTTP request &amp; response service; its Docker image tag at DockerHub is <code>kennethreitz/httpbin</code>.</p>"},{"location":"guides/creating-new-testcontainers/#creating-new-testcontainers-with-testcontainers-python-library","title":"Creating new Testcontainers with <code>testcontainers-python</code> library","text":"<p>You don't need to use Tomodachi Testcontainers if you don't want to. It's built on top of the testcontainers-python Python library, so that's all you need to start using Testcontainers.</p> <p>The <code>testcontainers-python</code> provides a base class for defining Docker Containers - <code>testcontainers.core.container.DockerContainer</code>. New containers are created by defining a new class and inheriting from the <code>DockerContainer</code> base class.</p> <p>Note</p> <p>The testcontainers-python library has a lot of Testcontainer examples. To learn more about creating and configuring Testcontainers in Python, take a look at the library's source code.</p> <pre><code>from typing import Generator\n\nimport pytest\nimport requests\nfrom testcontainers.core.container import DockerContainer\nfrom testcontainers.core.waiting_utils import wait_for_logs\n\n\nclass HTTPBinContainer(DockerContainer):\n    def __init__(self, internal_port: int = 80, edge_port: int = 8080) -&gt; None:\n        super().__init__(image=\"kennethreitz/httpbin\")\n        self.with_bind_ports(internal_port, edge_port)\n\n    def start(self, timeout: int = 60) -&gt; \"HTTPBinContainer\":\n        super().start()\n        wait_for_logs(self, r\"Listening at\", timeout=timeout)\n        return self\n\n\n@pytest.fixture(scope=\"session\")\ndef httpbin_container() -&gt; Generator[HTTPBinContainer, None, None]:\n    with HTTPBinContainer() as container:\n        yield container\n\n\ndef test_httpbin_container_started(httpbin_container: HTTPBinContainer) -&gt; None:\n    base_url = f\"http://localhost:{httpbin_container.get_exposed_port(80)}\"\n\n    response = requests.get(f\"{base_url}/status/200\", timeout=10)\n\n    assert response.status_code == 200\n</code></pre> <p>It's necessary to override the <code>start</code> method and include a waiter function that checks that the container has started. The <code>testcontainers-python</code> provides a <code>wait_for_logs</code> utility for searching log patterns with regular expressions. To ensure that the <code>HTTPBin</code> container has started, we're waiting until the container emits the <code>Listening at</code> log. Container creation is an asynchronous process - it takes time for the application inside the container to start, so if we're not waiting until the app is ready and try to use it immediately, the tests will fail.</p>"},{"location":"guides/creating-new-testcontainers/#creating-new-testcontainers-with-tomodachi-testcontainers-library","title":"Creating new Testcontainers with <code>tomodachi-testcontainers</code> library","text":"<p>Tomodachi Testcontainers have a couple of base classes for defining new Testcontainers:</p> <ul> <li><code>tomodachi_testcontainers.DockerContainer</code> - generic base class for all types of containers.</li> <li><code>tomodachi_testcontainers.WebContainer</code> - base class for web application containers.</li> <li><code>tomodachi_testcontainers.DatabaseContainer</code> - base class for relational database containers.</li> </ul>"},{"location":"guides/creating-new-testcontainers/#using-dockercontainer-for-generic-containers","title":"Using <code>DockerContainer</code> for generic containers","text":"<p>The <code>tomodachi_testcontainers.DockerContainer</code> base class inherits from <code>testcontainers.core.container.DockerContainer</code>. It adds some extra features - runs Testcontainers in a separate Docker network, forwards container logs to Python's standard logger, etc.</p> <p>It's used in the same way as the <code>testcontainers.core.container.DockerContainer</code>, except it requires the definition of a method <code>log_message_on_container_start</code>; it logs a custom message when a container starts. It helps to access a Testcontainer while debugging. Since the container's port is selected randomly for every test run, it's helpful to output an HTTP URL to be able to open an app running in the container and interact with it.</p> <pre><code>from typing import Generator\n\nimport pytest\nimport requests\nfrom testcontainers.core.waiting_utils import wait_for_logs\n\nfrom tomodachi_testcontainers import DockerContainer\nfrom tomodachi_testcontainers.utils import get_available_port\n\n\nclass HTTPBinContainer(DockerContainer):\n    def __init__(self, internal_port: int = 80, edge_port: int | None = None) -&gt; None:\n        super().__init__(image=\"kennethreitz/httpbin\")\n        self.with_bind_ports(internal_port, edge_port or get_available_port())\n\n    def log_message_on_container_start(self) -&gt; str:\n        return f\"HTTPBin container: http://localhost:{self.get_exposed_port(80)}\"\n\n    def start(self, timeout: int = 60) -&gt; \"HTTPBinContainer\":\n        super().start()\n        wait_for_logs(self, r\"Listening at\", timeout=timeout)\n        return self\n\n\n@pytest.fixture(scope=\"session\")\ndef httpbin_container() -&gt; Generator[DockerContainer, None, None]:\n    with HTTPBinContainer() as container:\n        yield container\n\n\ndef test_httpbin_container_started(httpbin_container: HTTPBinContainer) -&gt; None:\n    base_url = f\"http://localhost:{httpbin_container.get_exposed_port(80)}\"\n\n    response = requests.get(f\"{base_url}/status/200\", timeout=10)\n\n    assert response.status_code == 200\n</code></pre> <p>In the image below, the <code>log_message_on_container_start</code> outputs an HTTP URL to the debug console for accessing the container's app.</p> <p> </p> HTTPBin container URL is printed in the VSCode debug console (last row). <p>The <code>tomodachi_testcontainers.DockerContainer</code> forwards the container's logs to the pytest test output, which is useful for debugging what happened inside the container.</p> <p> </p> HTTPBin container logs are forwarded to pytest test output."},{"location":"guides/creating-new-testcontainers/#using-webcontainer-for-web-application-containers","title":"Using <code>WebContainer</code> for web application containers","text":"<p>Running web applications in containers is common, so <code>tomodachi_testcontainers.WebContainer</code> base class provides a convenient way to run web app containers.</p> <p>It works out of the box for web apps that run on a single port. Simply provide the <code>internal_port</code> and <code>edge_port</code>, and <code>WebContainer</code> will bind them. If you need to bind more ports, bind each port separately with the <code>with_bind_ports()</code> method.</p> <p>Note</p> <p>If <code>edge_port</code> is left as <code>None</code>, a random available port on a host machine is selected with <code>get_available_port()</code>.</p> <p>The <code>WebContainer</code> also provides an optional <code>http_healthcheck_path</code> param similar to the Docker Healthcheck. To wait until a web app inside the container has started, the <code>WebContainer</code> will continuously request the application's <code>http_healthcheck_path</code> endpoint until it returns the <code>HTTP 200</code> status code. This waiting strategy is more efficient and generic than waiting for the container's logs.</p> <p>Lastly, the <code>WebContainer</code> provides helper methods, e.g., <code>get_internal_url</code> and <code>get_external_url</code>, for fetching the container's HTTP endpoints. See all methods in the code reference.</p> <pre><code>from typing import Generator\n\nimport pytest\nimport requests\n\nfrom tomodachi_testcontainers import DockerContainer, WebContainer\n\n\nclass HTTPBinContainer(WebContainer):\n    def __init__(self, internal_port: int = 80, edge_port: int | None = None) -&gt; None:\n        super().__init__(\n            image=\"kennethreitz/httpbin\",\n            internal_port=internal_port,\n            edge_port=edge_port,\n            http_healthcheck_path=\"/status/200\",\n        )\n\n    def log_message_on_container_start(self) -&gt; str:\n        return f\"HTTPBin container: {self.get_external_url()}\"\n\n\n@pytest.fixture(scope=\"session\")\ndef httpbin_container() -&gt; Generator[DockerContainer, None, None]:\n    with HTTPBinContainer() as container:\n        yield container\n\n\ndef test_httpbin_container_started(httpbin_container: HTTPBinContainer) -&gt; None:\n    base_url = httpbin_container.get_external_url()\n\n    response = requests.get(f\"{base_url}/status/200\", timeout=10)\n\n    assert response.status_code == 200\n</code></pre>"},{"location":"guides/debugging-testcontainers/","title":"Debugging Testcontainers","text":"<p>Debugging failing Testcontainer tests can be tricky. The code is running in separate ephemeral Docker containers that are immediately deleted after the test run finishes.</p> <p>Below are some debugging and exploratory testing tips to help you debug failing Testcontainer tests.</p>"},{"location":"guides/debugging-testcontainers/#1-inspect-container-logs","title":"1. Inspect container logs","text":"<p>Logs are the main source of information when debugging Testcontainers. Generally, you should be able to pinpoint any problem by looking at the container logs in the same way as you'd investigate a problem in a production environment. If you find it difficult to understand how the system behaves from the logs, it's a sign that the logging is insufficient and needs improvement.</p> <p>By default, <code>tomodachi_testcontainers</code> will forward all container logs to Python's standard logger as <code>INFO</code> logs when containers stop. See Forward Container Logs to pytest section for more information and examples of configuring pytest to show the logs.</p> <p>Running Testcontainer tests is a great way to do exploratory testing of the system, check out if log messages are meaningful, and it's easy to understand what the system is doing.</p>"},{"location":"guides/debugging-testcontainers/#2-pause-a-test-with-a-breakpoint-and-inspect-running-containers","title":"2. Pause a test with a breakpoint and inspect running containers","text":"<p>Testcontainers are ephemeral - they're removed immediately after the test run finishes. Sometimes, it's helpful to inspect the state of running containers, e.g., manually check the contents of a database, S3 buckets, message queues, or application logs.</p> <p>To do that, pause the execution of a test with a breakpoint and manually inspect running containers:</p> <pre><code>import httpx\nimport pytest\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_healthcheck_passes(http_client: httpx.AsyncClient) -&gt; None:\n    response = await http_client.get(\"/health\")\n\n    # The breakpoint will pause the execution of the test\n    # and allow you to inspect running Docker containers.\n    breakpoint()\n\n    assert response.status_code == 200\n    assert response.json() == {\"status\": \"ok\"}\n</code></pre>"},{"location":"guides/debugging-testcontainers/#3-use-helper-containers-and-tools-for-exploratory-testing","title":"3. Use helper containers and tools for exploratory testing","text":"<p>When logs are insufficient to understand what's going on, it's helpful to use other helper containers and tools for inspecting container state, e.g., what's in the database, S3 buckets, message queues, etc.</p> <p>Pause a test with a breakpoint and inspect running containers with other tools, for example:</p> <ul> <li>Use AWS CLI with <code>aws --endpoint-url=http://localhost:&lt;port&gt;</code> to inspect the state of <code>LocalStack</code> or <code>Moto</code> containers.   Find out <code>LocalStack</code> or <code>Moto</code> port in the debug console output or inspect the containers with <code>docker ps</code>.</li> <li><code>Moto</code> provides a convenient web UI dashboard.   Find the link to the Moto dashboard in the pytest console output.</li> <li>Use the <code>DynamoDBAdminContainer</code> to inspect the state of DynamoDB tables.</li> </ul>"},{"location":"guides/debugging-testcontainers/#4-attach-a-remote-debugger-to-a-running-container","title":"4. Attach a remote debugger to a running container","text":"<p>As a last resort, you can attach a remote debugger to an application running in a remote container, e.g., to a <code>TomodachiContainer</code> running your application code.</p> <p>If using <code>VScode</code>, see the VSCode documentation of attaching a remote debugger to a running process over HTTP.</p> <pre><code>\"\"\"An example of attaching a debugger to a running Tomodachi container.\n\nGenerally you won't need a debugger in the testcontainer often,\nbecause you should be able to detect most issues by checking the logs,\nin the same way as you would to when investigating an issue in a production environment.\n\"\"\"\n\nfrom typing import AsyncGenerator, Generator\n\nimport httpx\nimport pytest\nimport pytest_asyncio\n\nfrom tomodachi_testcontainers import DockerContainer, TomodachiContainer\n\n\n@pytest.fixture(scope=\"module\")\ndef tomodachi_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        (\n            TomodachiContainer(testcontainer_image)\n            # Bind debugger port.\n            .with_bind_ports(5678, 5678)\n            # Explicitly install debugpy. Adding the debugpy to dev dependencies in pyproject will not work\n            # because the image is using the 'release' target which doesn't include dev dependencies.\n            # Adding the debugpy to production dependencies is not recommended.\n            .with_command(\n                'bash -c \"pip install debugpy; python -m debugpy --listen 0.0.0.0:5678 -m tomodachi run src/healthcheck.py --production\"'  # pylint: disable=line-too-long\n            )\n        ) as container\n    ):\n        yield container\n\n\n@pytest_asyncio.fixture(scope=\"module\", loop_scope=\"session\")\nasync def http_client(tomodachi_container: TomodachiContainer) -&gt; AsyncGenerator[httpx.AsyncClient, None]:\n    async with httpx.AsyncClient(base_url=tomodachi_container.get_external_url()) as client:\n        yield client\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_healthcheck_passes(http_client: httpx.AsyncClient) -&gt; None:\n    # To start the debugging, place a breakpoint in the test and in the production code.\n    # If using VSCode, run the test in the debugger and then attach the remote debugger on container port 5678.\n\n    # https://code.visualstudio.com/docs/python/debugging#_debugging-by-attaching-over-a-network-connection\n    # See .vscode/launch.example.json.\n\n    # Timeout set to None to avoid getting a TimeoutError while working in the debugger.\n    response = await http_client.get(\"/health\", timeout=None)\n\n    # Set a breakpoint after sending the HTTP request to the container, e.g. on the next line.\n    # It will trigger the breakpoint set in the production code and won't stop the running containers while debugging.\n    assert response.status_code == 200\n    assert response.json() == {\"status\": \"ok\"}\n</code></pre>"},{"location":"guides/debugging-testcontainers/#5-inspect-testcontainers-with-testcontainers-desktop-app","title":"5. Inspect Testcontainers with Testcontainers Desktop App","text":"<p>Testcontainers Desktop app allows you to prevent container shutdown so you can inspect and debug them, and it has some other extra features.</p>"},{"location":"guides/exporting-test-coverage/","title":"Exporting Test Coverage","text":"<p>When testing applications that run in Docker containers, their code coverage will not be included in the report by default.</p> <p>Assuming you're using coverage.py or pytest-cov, to get the code coverage from the Testcontainer, you need to export the <code>.coverage</code> file from the container to the host machine and append it to the root <code>.coverage</code> report.</p> <p>To generate the code coverage report from <code>TomodachiContainer</code>, start the container with the <code>coverage run -m tomodachi run ...</code> command. The <code>coverage</code> tool will keep track of the code that has been executed, and write the coverage report to <code>.coverage</code> file when the container stops.</p> <pre><code>from typing import Generator\n\nimport pytest\n\nfrom tomodachi_testcontainers import DockerContainer, TomodachiContainer\n\n\n@pytest.fixture(scope=\"module\")\ndef tomodachi_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with TomodachiContainer(testcontainer_image).with_command(\n        \"coverage run -m tomodachi run src/healthcheck.py --production\"\n    ) as container:\n        yield container\n</code></pre> <p>Configure the <code>coverage</code> tool in the <code>pyproject.toml</code> file:</p> <pre><code>[tool.poetry.group.test]\noptional = true\n\n[tool.poetry.group.test.dependencies]\npytest-cov = \"^4.1.0\"\n\n[tool.coverage.run]\nbranch = true\nsource = [\"src/\"]\n</code></pre> <p>To signal the <code>TomodachiContainer</code> to export the <code>.coverage</code> file when the container stops, set the <code>TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE</code> environment variable to <code>1</code>. Coverage export is disabled by default not to pollute the host machine with <code>.coverage</code> files. Generally, you'll be running tests with coverage in the deployment pipeline, so set the environment variable in the CI/CD server configuration.</p> <p>Tying it all together, run <code>pytest</code> with the coverage mode. The <code>.coverage</code> file will be saved in the current working directory on the host machine.</p> <pre><code>TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE=1 pytest --cov --cov-branch\n</code></pre> <p>Here's an example of how this project runs tests with code coverage in the deployment pipeline (dev.py).</p> <pre><code>coverage erase\n\nTOMODACHI_TESTCONTAINER_EXPORT_COVERAGE=1 pytest \\\n    --cov\n    --cov-append \\\n    --cov-branch \\\n    --cov-report=xml:build/coverage.xml \\\n    --cov-report=html:build/htmlcov \\\n    -v \\\n    --junitxml=build/tests.xml\n</code></pre> <p>If source code paths are different in the container and on the host machine, e.g., because the container is running in a different directory, you might have to re-map the paths with <code>coverage</code> tool. See Re-mapping paths in the <code>coverage.py</code> documentation.</p> <p>See an example of how the combined test coverage looks at https://app.codecov.io/gh/filipsnastins/tomodachi-testcontainers. The examples/ services are tested only with Testcontainer tests; their coverage is included in the final report.</p>"},{"location":"guides/forward-container-logs-to-pytest/","title":"Forward Container Logs to pytest","text":"<p>Logs from a container are forwarded to Python's standard logger as <code>INFO</code> logs when <code>DockerContainer</code> context manager exits.</p> <p>To see the logs in pytest, set the log level to at least <code>INFO</code> in the pytest configuration.</p> <pre><code>[tool.pytest.ini_options]\nlog_level = \"INFO\"\n</code></pre> <p>Success</p> <p>Capturing container logs is useful to see what has happened inside a container when a test has failed. It's especially useful if tests have failed in the deployment pipeline, because the containers are immediately deleted after the test run, and there's nothing else to inspect apart from the logs.</p> <p>By default, pytest won't show any output if all tests pass. To see the logs in the console, run <code>pytest</code> with <code>-rA</code> flag, e.g., <code>pytest -rA</code>. It will show A(ll) test summary, including captured logs.</p> <pre><code>-r chars   Show extra test summary info as specified by chars:\n    (f)ailed, (E)rror, (s)kipped, (x)failed, (X)passed,\n    (p)assed, (P)assed with output, (a)ll except passed (p/P), or (A)ll.\n    (w)arnings are enabled by default (see --disable-warnings),\n    'N' can be used to reset the list. (default: 'fE').\n</code></pre> <p>Example log output:</p> <pre><code>pytest tests/services/test_service_healthcheck.py -rA\n</code></pre> <p></p> <pre><code>pytest tests/services/test_service_s3.py -k test_upload_and_read_file\n</code></pre> <p></p>"},{"location":"guides/improving-test-performance/","title":"Improving Testcontainer Test Performance","text":"<p>TODO https://softwaregarden.dev/en/posts/testcontainers/parallel-start-with-prepulling/</p>"},{"location":"guides/managing-test-isolation/","title":"Managing Test Isolation","text":"<p>Test isolation is about ensuring that one test's result doesn't impact another test's result. We want our tests to be deterministic and not dependent on other tests. If tests are not isolated, they become flaky - they sometimes fail because the system's state was modified elsewhere. Flaky tests erode the trust in the test suite - we stop trusting our automated tests and soon abandon them altogether. Therefore, we should ensure that our tests are robust and isolated.</p> <p>There are many techniques for test isolation. For example, the Django framework's test client provides a <code>TransactionTestCase</code> helper that rollbacks database transactions after every test, ensuring that the database is always in a known state. This approach works for lower-level tests with direct access to the framework code, but doesn't work for Testcontainer test. We don't have access to internal working details for a particular framework on the end-to-end test level. We're testing an application's public API, disregarding any implementation details of frameworks and other libraries that power our applications.</p> <p>When writing end-to-end tests with Testcontainers, we should use other test isolation approaches, which often are simpler than rollbacking transactions or resetting databases after every test. Here's a list of the most common options, ordered from fastest to slowest in terms of test performance:</p> <ul> <li>Managing test isolation with the application's means (recommended!).</li> <li>Recreating specific resources after every test, for example, a database table or S3 bucket.</li> <li>Recreating some Testcontainers after every test.</li> <li>Recreating all Testcontainers after every test (not recommended!).</li> </ul>"},{"location":"guides/managing-test-isolation/#managing-test-isolation-with-the-applications-means","title":"Managing test isolation with the application's means","text":"<p>It's a good practice to start Testcontainers only once per test session; it takes time for containers to start, so recreating them after every test significantly impacts test performance. However, working with the same containers creates challenges with managing test isolation because each test will leave new or changed data behind.</p> <p>Luckily, your application under test already has some way of managing isolation - TODO</p>"},{"location":"guides/managing-test-isolation/#draft","title":"Draft","text":"<p>There are multiple approaches for managing test isolation:</p> <ul> <li> <p>Restart containers after every test so that applications always start from a known clean state - the easiest but the slowest approach.   Remove <code>scope=\"session\"</code> from Testcontainer's <code>@pytest.fixture</code> definition.</p> </li> <li> <p>Truncating/recreating datastores after every test - faster than restarting the entire container.   For example, we could recreate an S3 bucket or database table after every test.</p> </li> <li> <p>Managing test isolation with the application means - the fastest approach, but it might not be feasible in all use cases.   Most applications have a way of managing their data isolation, e.g., applications that scope what data a logged-in user can see.</p> </li> </ul>"},{"location":"guides/parallelizing-tests/","title":"Parallelizing Tests","text":"<p>Running tests in parallel reduces deployment pipeline runtime and shortens the feedback loop developers get from the tests.</p> <p>Tests that use Testcontainers are fast even when run sequentially; however, in certain circumstances, they can be slow:</p> <ul> <li>Tests are not isolated, and containers are restarted or recreated after every test to prevent state leaks.</li> <li>Tests rely on slow dependencies.</li> <li>The application under test performs compute-intensive tasks.</li> <li>The application under test is slow due to a bug.</li> </ul> <p>If the tests are slow due to a bug in the application code, consider fixing the root cause; parallelizing tests will hide the problem from the tests and let it slip into production. If the tests are slow due to the problematic test design or inherently slow dependencies, parallelizing tests will improve the runtime. However, if time allows, consider improving the test design, for example, by starting all containers once per test run and managing data isolation with the application means.</p> <p>Try it out!</p> <p>Experiment with running tests in parallel - it will save you time if the tests are run frequently (as they should be).</p>"},{"location":"guides/parallelizing-tests/#parallelizing-tests-with-pytest-xdist","title":"Parallelizing tests with pytest-xdist","text":"<p>The pytest-xdist plugin allows running tests in parallel across multiple CPUs. To get started, install the plugin with <code>pip install pytest-xdist</code>, and run pytest in parallel mode:</p> <pre><code>pytest -n auto\n</code></pre> <p>With the <code>-n auto</code> flag, the tests are distributed across all available CPU cores. Refer to the pytest-xdist documentation for detailed usage options.</p> <p><code>pytest-xdist</code> runs tests across multiple separate worker processes. A worker is assigned a subset of tests, and each worker will create its own set of Testcontainers, i.e., run all <code>pytest</code> fixtures independently, even the session-scoped fixtures. It will increase the number of running containers by the number of test workers and ultimately use more resources.</p> <p>Note</p> <p>Running tests in parallel requires more compute resources. Generally, it's not a problem, but be mindful of the associated costs and resource usage limits, especially with cloud CI/CD platforms.</p> <p>Since test workers are isolated, there shouldn't be any problems with test data leaks between the workers, unless they're competing for the same global resources, e.g., writing to files with the same name. To fix such problems, separate the resources with unique identifiers (namespaces): temporary path and file fixtures (<code>tmp_path</code> and similar fixtures from <code>pytest</code>) and unique test run prefixes (<code>testrun_uid</code> fixture from <code>pytest-xdist</code>).</p>"},{"location":"guides/ports-and-adapters/","title":"Decoupling and Testing Infrastructure Layer with Ports &amp; Adapters Pattern","text":"<p>TODO: https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)</p>"},{"location":"guides/running-testcontainer-tests-in-ci-cd/","title":"Running Testcontainer Tests in CI/CD","text":"<p>TODO: https://github.com/filipsnastins/tomodachi-testcontainers-github-actions</p>"},{"location":"guides/testing-apps-built-with-other-frameworks/","title":"Testing Applications Built with other Frameworks like Flask, FastAPI, or Django","text":"<p>With Testcontainers, you can test any app running in a container.</p> <p>Using the <code>testcontainer_image</code> pytest fixture, you can build a Docker image with Dockerfile from a current working directory. Then, you can use the built Docker image ID to start a new container. To learn how to create your new Testcontainers, see the previous guide - Creating new Testcontainers.</p> <p>Below are examples of running Flask, FastAPI, and Django applications with Testcontainers. The specific framework doesn't matter as long as it runs in a container.</p>"},{"location":"guides/testing-apps-built-with-other-frameworks/#flask-example","title":"Flask example","text":"src/flask_app.py<pre><code>import os\n\nfrom flask import Flask, Response, jsonify\n\napp = Flask(__name__)\n\n\n@app.route(\"/hello\")\ndef hello_api() -&gt; Response:\n    greet = os.getenv(\"GREET\", \"stranger\")\n    return jsonify({\"message\": f\"Hello from Flask, {greet}!\"})\n\n\n@app.route(\"/health\")\ndef healthcheck_api() -&gt; Response:\n    return jsonify({\"status\": \"ok\"})\n</code></pre> tests/test_flask_app.py<pre><code>from typing import Generator\n\nimport pytest\nimport requests\n\nfrom tomodachi_testcontainers import DockerContainer, WebContainer\n\n\nclass FlaskContainer(WebContainer):\n    def __init__(self, image: str) -&gt; None:\n        super().__init__(\n            image=image,\n            internal_port=5000,\n            http_healthcheck_path=\"/health\",\n        )\n\n    def log_message_on_container_start(self) -&gt; str:\n        return f\"Flask web app: http://localhost:{self.edge_port}\"\n\n\n@pytest.fixture(scope=\"session\")\ndef flask_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        FlaskContainer(testcontainer_image)\n        .with_env(\"GREET\", \"Testcontainers\")\n        .with_command(\"flask --app creating_testcontainers/flask_app.py run --host 0.0.0.0 --port 5000\")\n    ) as container:\n        yield container\n\n\ndef test_greetings_from_flask(flask_container: FlaskContainer) -&gt; None:\n    base_url = flask_container.get_external_url()\n\n    response = requests.get(f\"{base_url}/hello\", timeout=10)\n\n    assert response.json() == {\"message\": \"Hello from Flask, Testcontainers!\"}\n</code></pre>"},{"location":"guides/testing-apps-built-with-other-frameworks/#fastapi-example","title":"FastAPI example","text":"src/fastapi_app.py<pre><code>import os\n\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/hello\")\nasync def hello_api() -&gt; dict:\n    greet = os.getenv(\"GREET\", \"stranger\")\n    return {\"message\": f\"Hello from FastAPI, {greet}!\"}\n\n\n@app.get(\"/health\")\nasync def healthcheck_api() -&gt; dict:\n    return {\"status\": \"ok\"}\n</code></pre> tests/test_fastapi_app.py<pre><code>from typing import Generator\n\nimport pytest\nimport requests\n\nfrom tomodachi_testcontainers import DockerContainer, WebContainer\n\n\nclass FastAPIContainer(WebContainer):\n    def __init__(self, image: str) -&gt; None:\n        super().__init__(\n            image,\n            internal_port=8000,\n            http_healthcheck_path=\"/health\",\n        )\n\n    def log_message_on_container_start(self) -&gt; str:\n        return f\"FastAPI web app: http://localhost:{self.edge_port}\"\n\n\n@pytest.fixture(scope=\"session\")\ndef fastapi_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        FastAPIContainer(testcontainer_image)\n        .with_env(\"GREET\", \"Testcontainers\")\n        .with_command(\"uvicorn creating_testcontainers.fastapi_app:app --host 0.0.0.0 --port 8000\")\n    ) as container:\n        yield container\n\n\ndef test_greetings_from_fastapi(fastapi_container: FastAPIContainer) -&gt; None:\n    base_url = fastapi_container.get_external_url()\n\n    response = requests.get(f\"{base_url}/hello\", timeout=10)\n\n    assert response.json() == {\"message\": \"Hello from FastAPI, Testcontainers!\"}\n</code></pre>"},{"location":"guides/testing-apps-built-with-other-frameworks/#django-example","title":"Django example","text":"src/django_app/django_app/views.py<pre><code>import os\n\nfrom django.http import HttpRequest, JsonResponse\n\n\ndef hello_api(request: HttpRequest) -&gt; JsonResponse:\n    greet = os.getenv(\"GREET\", \"stranger\")\n    return JsonResponse({\"message\": f\"Hello from Django, {greet}!\"})\n\n\ndef healthcheck_api(request: HttpRequest) -&gt; JsonResponse:\n    return JsonResponse({\"status\": \"ok\"})\n</code></pre> tests/test_django_app.py<pre><code>from typing import Generator\n\nimport pytest\nimport requests\n\nfrom tomodachi_testcontainers import DockerContainer, WebContainer\n\n\nclass DjangoContainer(WebContainer):\n    def __init__(self, image: str) -&gt; None:\n        super().__init__(\n            image=image,\n            internal_port=8000,\n            http_healthcheck_path=\"/health\",\n        )\n\n    def log_message_on_container_start(self) -&gt; str:\n        return f\"Django web app: http://localhost:{self.edge_port}\"\n\n\n@pytest.fixture(scope=\"session\")\ndef django_container(testcontainer_image: str) -&gt; Generator[DockerContainer, None, None]:\n    with (\n        DjangoContainer(testcontainer_image)\n        .with_env(\"GREET\", \"Testcontainers\")\n        .with_command(\"python creating_testcontainers/django_app/manage.py runserver 0.0.0.0:8000\")\n    ) as container:\n        yield container\n\n\ndef test_greetings_from_django(django_container: DjangoContainer) -&gt; None:\n    base_url = django_container.get_external_url()\n\n    response = requests.get(f\"{base_url}/hello\", timeout=10)\n\n    assert response.json() == {\"message\": \"Hello from Django, Testcontainers!\"}\n</code></pre>"},{"location":"guides/testing-databases/","title":"Testing Databases","text":""},{"location":"guides/testing-databases/#using-in-memory-sqlite-database-in-tests","title":"Using in-memory SQLite database in tests","text":""},{"location":"guides/testing-databases/#use-case","title":"Use case","text":"<p>If an application uses a relational database and Object-Relational Mapper (ORM) for implementing a data layer, it's easy to replace a production database, e.g., PostgreSQL or MySQL, with an in-memory SQLite database. SQLite does not require additional setup or dependencies, and it might seem like a convenient choice for autotests.</p> <p>For example, using SQLAlchemy, set the database URL to <code>sqlite://</code> to connect to an in-memory SQLite database; it will use the built-in Python module <code>sqlite3</code>:</p> <pre><code>from sqlalchemy import create_engine\n\nengine = create_engine(\"sqlite://\")\n</code></pre>"},{"location":"guides/testing-databases/#drawbacks","title":"Drawbacks","text":"<p>Using SQLite in tests creates compatibility problems between the SQLite and your production database because the two database technologies support different features and implement some SQL statements differently.</p> <p>ORMs try to abstract these differences, especially different SQL flavors, but don't eliminate them. ORMs are not designed to enable a switch from one relational database technology to another without changes to the application code.</p> <p>When using SQLite for testing, the application code must only use standard features available in the SQLite and production databases. This cuts the benefits an application can get by using unique features of a particular database technology, potentially lowering performance and increasing the complexity of the application code.</p> <p>Testing with SQLite does not guarantee that the application will work in production.</p> <p>Theres's no guarantee that the application that passed the tests using SQLite will work in the production environment with the production database. An ORM can still fail to work with the production database due to unknown differences in behavior.</p>"},{"location":"guides/testing-databases/#using-a-production-like-database-in-tests-with-testcontainers","title":"Using a production-like database in tests with Testcontainers","text":"<p>Autotests must give confidence that the application will work in the production environment, so development/test/production environment parity is crucial for reliable automated testing.</p> <p>Use production-like database in tests</p> <p>Whether your application uses a relational or NoSQL database, use the same database technology, version, and configuration in automated tests as in your production environment.</p> <p>Testconainters lets you easily create and delete a temporary database when the tests finish.</p> <p>For the application to use the test database, inject the test database URL into the application configuration; using environment variables for managing configuration is a good practice.</p> <p>Below is an example of configuring the Flask application with the <code>PostgreSQLContainer</code> Testcontainer. The <code>postgres_container</code> fixture creates a new instance of the PostgreSQL database and deletes it when tests finish. The Flask application reads the database URL from the <code>DATABASE_URL</code> environment variable; set it before running the Flask application factory <code>create_app</code>.</p> <pre><code>import pytest\nfrom flask import Flask\nfrom tomodachi_testcontainers import PostgreSQLContainer\n\nfrom my_project import create_app\n\n@pytest.fixture\ndef app(monkeypatch: pytest.MonkeyPatch, postgres_container: PostgreSQLContainer) -&gt; Flask:\n    monkeypatch.setenv(\"DATABASE_URL\", str(postgres_container.get_external_url()))\n    return create_app()\n</code></pre> <p>The same approach works with other database technologies: MongoDB, DynamoDB, etc.</p>"},{"location":"guides/testing-databases/#improving-database-performance-in-tests","title":"Improving database performance in tests","text":"<p>Modern databases are already fast enough to be used in automated testing - startup time is less than a second, and database read/write performance lets you run hundreds of tests in a reasonable time.</p> <p>The slowest database operation is writing data to a disk on a commit. The test database is deleted when autotests finish, so the test data is discarded anyway. Therefore, to increase the test database performance, disable data flush to disk and let the database store the data in faster RAM. Read more about this technique and performance measurements in this blog post.</p> <p>Most databases have a similar configuration option that disables the flush to the disk. To disable the flush to the disk in PostgreSQL, set the <code>fsync</code> parameter to <code>off</code>:</p> <pre><code>docker run --rm -p 5432:5432 postgres:16 -c fsync=off\n</code></pre> <p>In MySQL set <code>innodb_flush_method=O_DIRECT_NO_FSYNC</code>:</p> <pre><code>docker run --rm -p 3306:3306 mysql:8 --innodb_flush_method=O_DIRECT_NO_FSYNC\n</code></pre> <p>Tip</p> <p>In Tomodachi Testcontainers library, database containers have <code>fsync</code> disabled by default.</p>"},{"location":"guides/testing-databases/#replacing-the-database-with-fakes-or-mocks","title":"Replacing the database with fakes or mocks","text":"<p>The previous section described testing with a production-like database to verify that interactions between an application and the database will work in the production environment. However, when writing unit tests that exercise individual application components in isolation, you might find that the database is getting in the way - test data is tedious to set up, and the database setup code obscures the intent of the test. It might signal that the system component under test is unnecessarily tightly coupled to the database, making it difficult to test its behavior.</p> <p>In this case, the system might benefit from separating the data storage layer from the business logic layer. The Repository pattern is an abstraction over the data storage layer. It wraps database operations in an interface and hides the complexity and mechanics of the database. When using the Repository pattern, the business logic doesn't directly call ORM models or database drivers to access data storage but does so indirectly through the Repository interface.</p> <p>To test the business logic without the complexity of the production database, substitute the real Repository with a fake or mock. To ensure the data storage layer works, separately test the real Repository implementation with the production database; it's described in Testing Repositories.</p> <p>To learn more about the Repository pattern use cases, check out cosmicpython book chapter on the topic and the original pattern description in the PoEAA catalog.</p> <p>Since examples in this section focused on relational databases, it's worth mentioning that the Repository pattern is database technology agnostic - see an example implementation with DynamoDB.</p>"},{"location":"guides/testing-databases/#references","title":"References","text":"<ul> <li>https://12factor.net/dev-prod-parity</li> <li>https://12factor.net/config</li> <li>http://michael.robellard.com/2015/07/dont-test-with-sqllite-when-you-use.html</li> <li>https://pythonspeed.com/articles/faster-db-tests/</li> <li>https://www.cosmicpython.com/book/chapter_02_repository.html</li> <li>https://martinfowler.com/eaaCatalog/repository.html</li> <li>https://ddd.mikaelvesavuori.se/tactical-ddd/repositories</li> </ul>"},{"location":"guides/testing-repositories/","title":"Testing Repositories","text":"<p>The Repository pattern is an abstraction over the data storage layer. It wraps database operations in an interface and hides the complexity and mechanics of the database. The domain layer uses the Repository to query and persist domain objects. From the domain layer point of view, the Repository's interface looks like an in-memory domain object collection.</p> <p>The Repository's responsibility is object retrieval and persistence - it contains no business logic. Therefore, all business logic resides in the domain objects, not the data layer. This separation of responsibilities makes testing and reasoning about the core application's behavior easier. In tests, you'll provide an in-memory object to the domain logic you want to test without being burdened by the test data setup through the production database.</p> <p>The Repository pattern is described in detail in the PoEAA and DDD. Other great resources I know of are: cosmicpython book's chapter on Repositories, Repositories for DDD on AWS, and designing persistence layer with .NET example.</p> <p>The following sections will explore testing Repositories separately from the rest of the application.</p>"},{"location":"guides/testing-repositories/#implementing-a-simple-repository","title":"Implementing a simple Repository","text":"<p>The Repository implementation will differ depending on the database technology (relational, NoSQL, file store, etc.) and the framework (ORM, datastore client library, etc.). The most important part is not exposing the underlying technology in the Repository's interface.</p>"},{"location":"guides/testing-repositories/#implementing-domain-object","title":"Implementing domain object","text":"<p>Before exploring how to test a Repository, we must create a domain object that the Repository will save and query. We'll use a <code>Customer</code> object as an example.</p> <p>There are two ways to create a new <code>Customer</code> object instance - with the default constructor (auto-generated with <code>@dataclass</code>) or a <code>create</code> factory method. The former is used for object reconstruction and the latter for new object creation.</p> customers/domain.py<pre><code>import uuid\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Customer:\n    id: str\n    name: str\n    email: str\n\n    @staticmethod\n    def create(name: str, email: str) -&gt; \"Customer\":\n        return Customer(\n            id=str(uuid.uuid4()),\n            name=name,\n            email=email,\n        )\n</code></pre> <p>When you're querying an existing object, e.g., by customer identifier or email address, the object is reconstructed from existing data from a datastore. When the data layer is separated from the domain layer, the Repository is responsible for reconstructing the objects. The domain layer provides an interface for object reconstruction - the object constructor method (<code>__init__</code>).</p> <p>To create a new, unique customer, e.g., when a user registers in your application, we'll use the new object creation method - <code>create</code>. The <code>create</code> method requires the data to create a new customer - <code>name</code> and <code>email</code>. Unlike <code>__init__</code>, the <code>create</code> method doesn't require the <code>id</code>; the new random <code>uuid</code> is generated inside the <code>create</code> method. Therefore, the new object creation method encapsulates the rules of a new object creation - in this example, the <code>Customer.id</code> generation - and offloads this responsibility from the data layer.</p> <p>We'll see how separating the object reconstruction from the new object creation is useful when implementing a sample Repository.</p>"},{"location":"guides/testing-repositories/#implementing-dynamodb-repository","title":"Implementing DynamoDB Repository","text":"<p>In this example, we'll use AWS DynamoDB to implement <code>DynamoDBCustomerRepository</code>. The sample Repository has two methods - constructor (<code>__init__</code>) and <code>save</code> method.</p> <p>The constructor takes two dependencies - <code>DynamoDBClient</code> and <code>table_name</code>. Explicitly passing the dependencies increases flexibility - the Repository will be easy to configure in tests and in the production code, as we'll see in the following sections. The <code>save</code> method persists a <code>Customer</code> object in the database; its implementation is the minimal working version to showcase the example.</p> adapters/repository.py<pre><code>from types_aiobotocore_dynamodb import DynamoDBClient\n\nfrom .domain001 import Customer\n\n\nclass DynamoDBCustomerRepository:\n    def __init__(self, client: DynamoDBClient, table_name: str) -&gt; None:\n        self._client = client\n        self._table_name = table_name\n\n    async def save(self, customer: Customer) -&gt; None:\n        await self._client.put_item(\n            TableName=self._table_name,\n            Item={\n                \"PK\": {\"S\": f\"CUSTOMER#{customer.id}\"},\n                \"Id\": {\"S\": customer.id},\n                \"Name\": {\"S\": customer.name},\n                \"Email\": {\"S\": customer.email},\n            },\n        )\n</code></pre>"},{"location":"guides/testing-repositories/#testing-with-a-production-like-database","title":"Testing with a production-like database","text":"<p>As we learned in the Testing Databases, we want to test the Repository with a production-like database. To test the DynamoDB Repository, we'll use Moto AWS service mocks. An alternative is using a real AWS account - that will make the tests accurate but slower and more complicated to configure securely due to permission and account management - if we're not careful, we can accidentally run the tests on a production AWS account. Service mocks like Moto or LocalStack are good enough for most use cases.</p> <p>To test the Repository, we need to instantiate it with <code>DynamoDBClient</code> and <code>table_name</code>. We'll get the <code>DynamoDBClient</code> from the Tomodachi Testcontainers library with the <code>moto_dynamodb_client</code> fixture. The fixture will automatically start <code>MotoContainer</code>. For the <code>table_name</code>, any string value will suffice; the example is using a value with a random <code>uuid</code> suffix as a namespace to avoid table name clashes during tests.</p> <p>Dependency injection increases testability</p> <p>Being able to pass a different <code>DynamoDBClient</code> to the Repository in tests is powerful - it makes the code testable and explicit about its dependencies. To configure the Repository in the production code, we'd create a new <code>DynamoDBClient</code> instance with configuration values from the environment variables.</p> <p>The first test <code>test_save_customer</code> creates a new <code>Customer</code> object and calls the <code>save</code> method to persist it in the database. The assertion is missing for now - we'll look into what to assert in the next section.</p> tests/test_repository.py<pre><code>import uuid\nfrom typing import AsyncGenerator\n\nimport pytest\nimport pytest_asyncio\nfrom types_aiobotocore_dynamodb import DynamoDBClient\n\nfrom .create_customers_table import create_customers_table\nfrom .domain001 import Customer\nfrom .repository001 import DynamoDBCustomerRepository\n\n\n@pytest_asyncio.fixture(loop_scope=\"session\")\nasync def repository(moto_dynamodb_client: DynamoDBClient) -&gt; AsyncGenerator[DynamoDBCustomerRepository, None]:\n    table_name = f\"autotest-{uuid.uuid4()}-customers\"\n    await create_customers_table(moto_dynamodb_client, table_name)\n    yield DynamoDBCustomerRepository(moto_dynamodb_client, table_name)\n    await moto_dynamodb_client.delete_table(TableName=table_name)\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_save_customer(repository: DynamoDBCustomerRepository) -&gt; None:\n    # Arrange\n    customer = Customer.create(name=\"John Doe\", email=\"john.doe@example.com\")\n\n    # Act\n    await repository.save(customer)\n\n    # Assert\n    ...\n</code></pre> <p>For the example completeness, the function below creates a new DynamoDB table.</p> tests/create_customers_table.py<pre><code>from types_aiobotocore_dynamodb import DynamoDBClient\n\n\nasync def create_customers_table(client: DynamoDBClient, table_name: str) -&gt; None:\n    await client.create_table(\n        TableName=table_name,\n        KeySchema=[\n            {\"AttributeName\": \"PK\", \"KeyType\": \"HASH\"},\n        ],\n        AttributeDefinitions=[\n            {\"AttributeName\": \"PK\", \"AttributeType\": \"S\"},\n        ],\n        BillingMode=\"PAY_PER_REQUEST\",\n    )\n</code></pre>"},{"location":"guides/testing-repositories/#test-the-interface-not-the-implementation","title":"Test the interface, not the implementation","text":"<p>To test that the Repository has saved an object in a database, we can query the database and assert that the data is stored correctly. This approach has a significant drawback - the tests know about the Repository's implementation details, such as how and where the data is stored. As more functionality is added to the Repository, the tests will become brittle, lengthy, and difficult to maintain.</p> tests/test_repository.py<pre><code>@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_save_customer(repository: DynamoDBCustomerRepository, moto_dynamodb_client: DynamoDBClient) -&gt; None:\n    # Arrange\n    customer = Customer.create(name=\"John Doe\", email=\"john.doe@example.com\")\n\n    # Act\n    await repository.save(customer)\n\n    # Assert\n    item = await moto_dynamodb_client.get_item(\n        TableName=repository._table_name,\n        Key={\"PK\": {\"S\": f\"CUSTOMER#{customer.id}\"}},\n    )\n    assert item[\"Item\"] == {\n        \"PK\": {\"S\": f\"CUSTOMER#{customer.id}\"},\n        \"Id\": {\"S\": customer.id},\n        \"Name\": {\"S\": \"John Doe\"},\n        \"Email\": {\"S\": \"john.doe@example.com\"},\n    }\n</code></pre> <p>To test the Repository, verify its behavior by calling only its public API - test the interface, not the implementation. The intent of the <code>test_save_customer</code> is to assert that the <code>Customer</code> object is saved to the Repository - that it's possible to retrieve it back from the Repository and that its data is the same. This way, the tests are not concerned with the database's internal data structure, which can now change independently without breaking the tests.</p> <p>The <code>DynamoDBCustomerRepository.get</code> reconstructs a customer's object from existing data from the database.</p> adapters/repository.py<pre><code>class DynamoDBCustomerRepository:\n    ...\n\n    async def get(self, customer_id: str) -&gt; Customer:\n        response = await self._client.get_item(\n            TableName=self._table_name,\n            Key={\"PK\": {\"S\": f\"CUSTOMER#{customer_id}\"}},\n        )\n        item = response[\"Item\"]\n        return Customer(\n            id=item[\"Id\"][\"S\"],\n            name=item[\"Name\"][\"S\"],\n            email=item[\"Email\"][\"S\"],\n        )\n</code></pre> <p>Repository's public API round-trip testing helps to avoid testing implementation details</p> <p>You can think of the pattern of saving an object and querying it in the same test as a \"round-trip\" test. The same test verifies a complete cycle of a domain object persistence - saved in the datastore and retrieved back. The example doesn't include updating the domain object, but the same idea applies - create (arrange), update (act), query (assert).</p> <p>To test a negative case when the <code>Customer</code> is not found in the Repository, we can test that the <code>get</code> method raises an exception. The current Repository implementation will throw the <code>KeyError</code> because the <code>Item</code> key will not exist in the DynamoDB <code>GetItem</code> API response. This test has the same problem as the first example - it asserts on the implementation detail - <code>KeyError</code>.</p> <p>The test shouldn't care if the internal data structure is a dictionary that throws the <code>KeyError</code> when the dictionary key is not found. In addition, the <code>KeyError</code> might not necessarily mean that the customer is not found in the Repository. If the Repository has a bug and is not saving the customer's object field, the same error will be raised when trying to access the unsaved field, e.g., <code>email=item[\"Email\"][\"S\"]</code>. In this case, the error handling code catching the <code>KeyError</code> will always treat it as the \"customer not found\" case and return misleading results to the application's end user.</p> tests/test_repository.py<pre><code>@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_not_found(repository: DynamoDBCustomerRepository) -&gt; None:\n    with pytest.raises(KeyError):\n        await repository.get(\"123456\")\n</code></pre> <p>To hide the exception's implementation details, we introduce a new domain exception - <code>CustomerNotFoundError</code> - to identify and handle the error unambiguously. The domain exception is part of the Repository's public API - when a customer with a given <code>customer_id</code> is not found, the <code>CustomerNotFoundError</code> is raised. All Repository's implementations must adhere to this public API or contract, regardless of the underlying database technology.</p> adapters/repository.py<pre><code>class DynamoDBCustomerRepository:\n    ...\n\n    async def get(self, customer_id: str) -&gt; Customer:\n        response = await self._client.get_item(\n            TableName=self._table_name,\n            Key={\"PK\": {\"S\": f\"CUSTOMER#{customer_id}\"}},\n        )\n        item = response.get(\"Item\")\n        if item is None:\n            raise CustomerNotFoundError(customer_id)\n        return Customer(\n            id=item[\"Id\"][\"S\"],\n            name=item[\"Name\"][\"S\"],\n            email=item[\"Email\"][\"S\"],\n        )\n</code></pre> tests/test_repository.py<pre><code>from .repository005 import CustomerNotFoundError\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_not_found(repository: DynamoDBCustomerRepository) -&gt; None:\n    with pytest.raises(CustomerNotFoundError):\n        await repository.get(\"123456\")\n</code></pre>"},{"location":"guides/testing-repositories/#implementing-a-fake-repository","title":"Implementing a fake Repository","text":"<p>The database implementation details obscure the intent of the application's business logic, so we have hidden the details behind the Repository's interface - a contract between the application's domain layer and persistence layer.</p> <p>To further ease domain layer testing, instead of using the production <code>DynamoDBCustomerRepository</code>, we can replace it with an in-memory fake Repository. The fake Repository will store the data in an in-memory dictionary. The in-memory version is unsuitable for real-world use because the data is lost on application shutdown, and the Repository is not scalable. However, if the fake Repository behaves the same as the real one, it's a good choice for unit testing, prototyping, and demos. There's no database or Testcontainers to manage, and the tests will be fast.</p> adapters/repository.py<pre><code>class InMemoryRepository:\n    def __init__(self, customers: list[Customer]) -&gt; None:\n        self.customers = {customer.id: customer for customer in customers}\n\n    async def save(self, customer: Customer) -&gt; None:\n        if customer.id in self.customers:\n            raise CustomerIdentifierAlreadyExistsError(customer.id)\n        if customer.email in (customer.email for customer in self.customers.values()):\n            raise CustomerEmailAlreadyExistsError(customer.email)\n        self.customers[customer.id] = customer\n\n    async def get(self, customer_id: str) -&gt; Customer:\n        try:\n            return self.customers[customer_id]\n        except KeyError as e:\n            raise CustomerNotFoundError(customer_id) from e\n</code></pre> <p>The in-memory repository is useful not just for testing; when modeling a complex and unknown domain, you can postpone the decision of which database technology to use and focus the development efforts on the problem domain. By using the Repository with a clean interface, you'll be able to quickly evolve the domain layer without being slowed down by the accidental complexities of a production database - mapping domain objects to the datastore format and back, managing schema and data migration, handling infrastructure errors, etc. You can better commit to a specific technology when the problem domain is more explored and apparent with how the data is queried and used.</p> <p>Let the problem domain drive your technological choices</p> <p>By focusing the development on the problem domain first and keeping the infrastructure concerns on the periphery, later, you can make informed choices of which specific technologies are better suited for your needs. It's a significant benefit of the broader Ports &amp; Adapters pattern - hiding accidental complexity of low-level components. The Ports &amp; Adapters apply to all systems - databases, file stores, external services, message brokers, etc.</p>"},{"location":"guides/testing-repositories/#testing-other-repository-implementations-with-the-same-test-suite","title":"Testing other Repository implementations with the same test suite","text":"<p>To ensure that the in-memory Repository works, we must test it with the same test suite as the production Repository. Since the interface is the same and tests are testing the interface, not the implementation, the test suite doesn't care which Repository it's given, in-memory, DynamoDB, PostgreSQL, AWS S3, etc., as long as the behavior is the same. Knowing this property, we could have implemented the in-memory repository and its tests before the DynamoDB version.</p> <p>To reuse the same test suite for testing multiple Repository versions, we'll use <code>pytest</code> parametrized fixtures. Any other popular test runner should have a similar concept. We'll define two fixtures, <code>dynamodb_repository</code> and <code>fake_repository</code>, and use them in the generic <code>repository</code> fixture. The <code>repository</code> fixture is parametrized; when a test case uses the fixture, it will be run twice - with <code>dynamodb</code> and <code>fake</code> parameters. Depending on the passed parameter, the fixture will return <code>DynamoDBCustomerRepository</code> or <code>InMemoryRepository</code>.</p> tests/test_repository.py<pre><code>import uuid\nfrom typing import AsyncGenerator, Generator\n\nimport pytest\nimport pytest_asyncio\nfrom types_aiobotocore_dynamodb import DynamoDBClient\n\nfrom .create_customers_table import create_customers_table\nfrom .domain006 import (\n    Customer,\n    CustomerEmailAlreadyExistsError,\n    CustomerIdentifierAlreadyExistsError,\n    CustomerNotFoundError,\n)\nfrom .ports006 import CustomerRepository\nfrom .repository006 import DynamoDBCustomerRepository, InMemoryRepository\n\n\n@pytest_asyncio.fixture(loop_scope=\"session\")\nasync def dynamodb_repository(moto_dynamodb_client: DynamoDBClient) -&gt; AsyncGenerator[DynamoDBCustomerRepository, None]:\n    table_name = f\"autotest-{uuid.uuid4()}-customers\"\n    await create_customers_table(moto_dynamodb_client, table_name)\n    yield DynamoDBCustomerRepository(moto_dynamodb_client, table_name)\n    await moto_dynamodb_client.delete_table(TableName=table_name)\n\n\n@pytest.fixture\ndef fake_repository() -&gt; InMemoryRepository:\n    return InMemoryRepository([])\n\n\n@pytest.fixture(params=[\"dynamodb\", \"fake\"])\ndef repository(\n    request: pytest.FixtureRequest,\n    dynamodb_repository: DynamoDBCustomerRepository,\n    fake_repository: InMemoryRepository,\n) -&gt; Generator[CustomerRepository, None, None]:\n    if request.param == \"dynamodb\":\n        yield dynamodb_repository\n    elif request.param == \"fake\":\n        yield fake_repository\n    else:\n        raise NotImplementedError\n</code></pre> <p>The tests use the generic <code>repository</code> fixture instead of a specific implementation and are run twice - with <code>DynamoDBCustomerRepository</code> and <code>InMemoryRepository</code>.</p> tests/test_repository.py<pre><code>from .ports006 import CustomerRepository\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_save_customer(repository: CustomerRepository) -&gt; None:\n    customer = Customer.create(name=\"John Doe\", email=\"john.doe@example.com\")\n\n    await repository.save(customer)\n\n    assert await repository.get(customer.id) == customer\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_not_found(repository: CustomerRepository) -&gt; None:\n    with pytest.raises(CustomerNotFoundError, match=\"123456\"):\n        await repository.get(\"123456\")\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_id_should_be_unique(repository: CustomerRepository) -&gt; None:\n    customer_id = str(uuid.uuid4())\n    customer_1 = Customer(id=customer_id, name=\"John Doe\", email=\"john.doe@example.com\")\n    customer_2 = Customer(id=customer_id, name=\"Mary Doe\", email=\"mary.doe@example.com\")\n    await repository.save(customer_1)\n\n    with pytest.raises(CustomerIdentifierAlreadyExistsError, match=customer_id):\n        await repository.save(customer_2)\n\n\n@pytest.mark.asyncio(loop_scope=\"session\")\nasync def test_customer_email_should_be_unique(repository: CustomerRepository) -&gt; None:\n    customer_1 = Customer.create(name=\"John Doe\", email=\"john.doe@example.com\")\n    customer_2 = Customer.create(name=\"John Doe\", email=\"john.doe@example.com\")\n    await repository.save(customer_1)\n\n    with pytest.raises(CustomerEmailAlreadyExistsError, match=\"john.doe@example.com\"):\n        await repository.save(customer_2)\n</code></pre> <p>For the type hint, the repository tests use the generic Repository's protocol - the \"Port\" part of the \"Ports &amp; Adapters\" pattern.</p> customers/ports.py<pre><code>from typing import Protocol\n\nfrom .domain006 import Customer\n\n\nclass CustomerRepository(Protocol):\n    async def save(self, customer: Customer) -&gt; None: ...\n\n    async def get(self, customer_id: str) -&gt; Customer: ...\n</code></pre> <p> </p> Running the same test suite with different pytest fixture implementations."},{"location":"guides/testing-repositories/#decoupling-and-testing-infrastructure-layer-with-ports-adapters-pattern","title":"Decoupling and Testing Infrastructure Layer with Ports &amp; Adapters Pattern","text":"<p>This section used the Repository pattern to decouple the persistence layer from the domain layer. The Repository pattern is a specific application for another, more general pattern - Ports &amp; Adapters. The Ports &amp; Adapters pattern helps decouple all sorts of components, not just databases. The following section Decoupling and Testing Infrastructure Layer with Ports &amp; Adapters Pattern describes in more detail the applications of Ports &amp; Adapters, and how Testcontainers help to implement and test the \"Adapters\" part of the pattern.</p> <p>The diagrams below (C4) showcase how the Ports &amp; Adapters pattern helps to implement the example Repository.</p> <p></p> <p>Ports are the interfaces of our infrastructure components; they reside in the domain layer. Adapters or the Infrastructure layer implement the Ports. There are two implementations - in-memory Repository and DynamoDB Repository. Testcontainers help to test the DynamoDB Repository in a production-like environment by provisioning AWS service mocks, e.g., LocalStack.</p> <p>The diagram shows that all dependencies (arrows) flow towards the domain layer. It means the domain layer doesn't depend on other infrastructure components. It makes the domain layer testable in isolation and makes it easier to understand the code.</p> <p></p>"},{"location":"guides/testing-repositories/#references","title":"References","text":"<ul> <li>https://martinfowler.com/eaaCatalog/repository.html</li> <li>https://martinfowler.com/bliki/DomainDrivenDesign.html</li> <li>https://www.cosmicpython.com/book/chapter_02_repository.html</li> <li>https://ddd.mikaelvesavuori.se/tactical-ddd/repositories</li> <li>https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design</li> <li>https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)</li> </ul>"},{"location":"reference/","title":"Tomodachi Testcontainers","text":""},{"location":"reference/#tomodachi_testcontainers","title":"tomodachi_testcontainers","text":""},{"location":"reference/#tomodachi_testcontainers.DockerContainer","title":"DockerContainer","text":"<pre><code>DockerContainer(*args, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code>, <code>ABC</code></p> <p>Abstract class for generic Docker containers.</p> PARAMETER DESCRIPTION <code>*args</code> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def __init__(self, *args: Any, disable_logging: bool = False, **kwargs: Any) -&gt; None:\n    self._set_container_network()\n\n    super().__init__(*args, **kwargs, network=self.network)\n\n    self._set_default_container_name()\n\n    self._disable_logging = disable_logging\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.log_message_on_container_start","title":"log_message_on_container_start  <code>abstractmethod</code>","text":"<pre><code>log_message_on_container_start()\n</code></pre> <p>Returns a message that will be logged when the container starts.</p> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>@abc.abstractmethod\ndef log_message_on_container_start(self) -&gt; str:\n    \"\"\"Returns a message that will be logged when the container starts.\"\"\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.get_container_internal_ip","title":"get_container_internal_ip","text":"<pre><code>get_container_internal_ip()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def get_container_internal_ip(self) -&gt; str:\n    return self.docker_inspect()[\"NetworkSettings\"][\"Networks\"][self.network][\"IPAddress\"]\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.get_container_gateway_ip","title":"get_container_gateway_ip","text":"<pre><code>get_container_gateway_ip()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def get_container_gateway_ip(self) -&gt; str:\n    return self.docker_inspect()[\"NetworkSettings\"][\"Networks\"][self.network][\"Gateway\"]\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.docker_inspect","title":"docker_inspect","text":"<pre><code>docker_inspect()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def docker_inspect(self) -&gt; Dict[str, Any]:\n    return self.get_docker_client().get_container(self.get_wrapped_container().id)\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def start(self) -&gt; \"DockerContainer\":\n    self._setup_logger()\n    self._start()\n    self._log_message_on_container_start()\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def stop(self) -&gt; None:\n    with suppress(Exception):\n        container = self._container or cast(Container, self.get_docker_client().client.containers.get(self._name))\n        container.remove(force=True, v=True)\n    self._container = None\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DockerContainer.restart","title":"restart","text":"<pre><code>restart()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def restart(self) -&gt; None:\n    self.get_wrapped_container().restart()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.EphemeralDockerImage","title":"EphemeralDockerImage","text":"<pre><code>EphemeralDockerImage(dockerfile=None, context=None, target=None, docker_client_kwargs=None, *, remove_image_on_exit=True)\n</code></pre> <p>Builds a Docker image from a given Dockerfile and removes it when the context manager exits.</p> PARAMETER DESCRIPTION <code>dockerfile</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>context</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>target</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>docker_client_kwargs</code> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> <code>remove_image_on_exit</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/image.py</code> <pre><code>def __init__(\n    self,\n    dockerfile: Optional[Path] = None,\n    context: Optional[Path] = None,\n    target: Optional[str] = None,\n    docker_client_kwargs: Optional[Dict] = None,\n    *,\n    remove_image_on_exit: bool = True,\n) -&gt; None:\n    self.dockerfile = str(dockerfile) if dockerfile else None\n    self.context = str(context) if context else \".\"\n    self.target = target\n    self._docker_client = DockerClient(**(docker_client_kwargs or {}))\n    self._remove_image_on_exit = remove_image_on_exit\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.EphemeralDockerImage.image","title":"image  <code>instance-attribute</code>","text":"<pre><code>image\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.EphemeralDockerImage.dockerfile","title":"dockerfile  <code>instance-attribute</code>","text":"<pre><code>dockerfile = str(dockerfile) if dockerfile else None\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.EphemeralDockerImage.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = str(context) if context else '.'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.EphemeralDockerImage.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = target\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer","title":"WebContainer","text":"<pre><code>WebContainer(image, internal_port, edge_port=None, http_healthcheck_path=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code>, <code>ABC</code></p> <p>Abstract class for web application containers.</p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>http_healthcheck_path</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def __init__(\n    self,\n    image: str,\n    internal_port: int,\n    edge_port: Optional[int] = None,\n    http_healthcheck_path: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(image, disable_logging=disable_logging, **kwargs)\n    self.internal_port = internal_port\n    self.edge_port = edge_port or get_available_port()\n    self.http_healthcheck_path = http_healthcheck_path\n    self.with_bind_ports(internal_port, self.edge_port)\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer.internal_port","title":"internal_port  <code>instance-attribute</code>","text":"<pre><code>internal_port = internal_port\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer.edge_port","title":"edge_port  <code>instance-attribute</code>","text":"<pre><code>edge_port = edge_port or get_available_port()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer.http_healthcheck_path","title":"http_healthcheck_path  <code>instance-attribute</code>","text":"<pre><code>http_healthcheck_path = http_healthcheck_path\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer.get_internal_url","title":"get_internal_url","text":"<pre><code>get_internal_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def get_internal_url(self) -&gt; str:\n    ip = self.get_container_internal_ip()\n    return f\"http://{ip}:{self.internal_port}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer.get_external_url","title":"get_external_url","text":"<pre><code>get_external_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def get_external_url(self) -&gt; str:\n    host = self.get_container_host_ip()\n    return f\"http://{host}:{self.edge_port}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WebContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def start(self) -&gt; \"WebContainer\":\n    super().start()\n    if self.http_healthcheck_path:\n        url = urllib.parse.urljoin(self.get_external_url(), self.http_healthcheck_path)\n        wait_for_http_healthcheck(url=url)\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DynamoDBAdminContainer","title":"DynamoDBAdminContainer","text":"<pre><code>DynamoDBAdminContainer(dynamo_endpoint, image='aaronshaf/dynamodb-admin:latest', internal_port=8001, edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>DynamoDB Admin container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> </ul> PARAMETER DESCRIPTION <code>dynamo_endpoint</code> <p> TYPE: <code>str</code> </p> <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'aaronshaf/dynamodb-admin:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>8001</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/dynamodb_admin.py</code> <pre><code>def __init__(\n    self,\n    dynamo_endpoint: str,\n    image: str = \"aaronshaf/dynamodb-admin:latest\",\n    internal_port: int = 8001,\n    edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image=image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=\"/\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\") or \"testing\"  # nosec: B105\n    self.aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\") or \"testing\"  # nosec: B105\n\n    self.with_env(\"AWS_REGION\", self.region_name)\n    self.with_env(\"AWS_DEFAULT_REGION\", self.region_name)\n    self.with_env(\"AWS_ACCESS_KEY_ID\", self.aws_access_key_id)\n    self.with_env(\"AWS_SECRET_ACCESS_KEY\", self.aws_secret_access_key)\n\n    self.with_env(\"DYNAMO_ENDPOINT\", dynamo_endpoint)\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DynamoDBAdminContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DynamoDBAdminContainer.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id = getenv('AWS_ACCESS_KEY_ID') or 'testing'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DynamoDBAdminContainer.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key = getenv('AWS_SECRET_ACCESS_KEY') or 'testing'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DynamoDBAdminContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/dynamodb_admin.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"DynamoDB Admin: http://localhost:{self.edge_port}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer","title":"LocalStackContainer","text":"<pre><code>LocalStackContainer(image='localstack/localstack:3', internal_port=4566, edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>LocalStack container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>AWS_ACCESS_KEY_ID</code> - defaults to <code>testing</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code> - defaults to <code>testing</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'localstack/localstack:3'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>4566</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"localstack/localstack:3\",\n    internal_port: int = 4566,\n    edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=\"/_localstack/health\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\") or \"testing\"  # nosec: B105\n    self.aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\") or \"testing\"  # nosec: B105\n\n    self.with_env(\"AWS_REGION\", self.region_name)\n    self.with_env(\"AWS_DEFAULT_REGION\", self.region_name)\n    self.with_env(\"AWS_ACCESS_KEY_ID\", self.aws_access_key_id)\n    self.with_env(\"AWS_SECRET_ACCESS_KEY\", self.aws_secret_access_key)\n\n    # Docker is needed for running AWS Lambda container\n    self.with_env(\"LAMBDA_DOCKER_NETWORK\", self.network)\n    self.with_volume_mapping(\"/var/run/docker.sock\", \"/var/run/docker.sock\")\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id = getenv('AWS_ACCESS_KEY_ID') or 'testing'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key = getenv('AWS_SECRET_ACCESS_KEY') or 'testing'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"LocalStack started: http://localhost:{self.edge_port}/\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer.get_aws_client_config","title":"get_aws_client_config","text":"<pre><code>get_aws_client_config()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def get_aws_client_config(self) -&gt; AWSClientConfig:\n    return AWSClientConfig(\n        region_name=self.region_name,\n        aws_access_key_id=self.aws_access_key_id,\n        aws_secret_access_key=self.aws_secret_access_key,\n        endpoint_url=self.get_external_url(),\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.LocalStackContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def start(self) -&gt; \"LocalStackContainer\":\n    super().start()\n    wait_for_logs(self, r\"Ready\\.\\n\", timeout=10.0)\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer","title":"MinioContainer","text":"<pre><code>MinioContainer(image='minio/minio:latest', s3_api_internal_port=9000, s3_api_edge_port=None, console_internal_port=9001, console_edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>Minio container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>MINIO_ROOT_USER</code> - defaults to <code>minioadmin</code></li> <li><code>MINIO_ROOT_PASSWORD</code> - defaults to <code>minioadmin</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'minio/minio:latest'</code> </p> <code>s3_api_internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>9000</code> </p> <code>s3_api_edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>console_internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>9001</code> </p> <code>console_edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"minio/minio:latest\",\n    s3_api_internal_port: int = 9000,\n    s3_api_edge_port: Optional[int] = None,\n    console_internal_port: int = 9001,\n    console_edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=s3_api_internal_port,\n        edge_port=s3_api_edge_port,\n        http_healthcheck_path=\"/minio/health/live\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n    self.s3_api_internal_port = s3_api_internal_port\n    self.s3_api_edge_port = self.edge_port\n    self.console_internal_port = console_internal_port\n    self.console_edge_port = console_edge_port or get_available_port()\n\n    self.with_bind_ports(console_internal_port, self.console_edge_port)\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.minio_root_user = os.getenv(\"MINIO_ROOT_USER\") or \"minioadmin\"  # nosec: B105\n    self.minio_root_password = os.getenv(\"MINIO_ROOT_PASSWORD\") or \"minioadmin\"  # nosec: B105\n\n    self.with_env(\"MINIO_ROOT_USER\", self.minio_root_user)\n    self.with_env(\"MINIO_ROOT_PASSWORD\", self.minio_root_password)\n\n    self.with_command(\n        f'server /data --address \":{self.s3_api_internal_port}\" --console-address \":{self.console_internal_port}\"'\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.s3_api_internal_port","title":"s3_api_internal_port  <code>instance-attribute</code>","text":"<pre><code>s3_api_internal_port = s3_api_internal_port\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.s3_api_edge_port","title":"s3_api_edge_port  <code>instance-attribute</code>","text":"<pre><code>s3_api_edge_port = edge_port\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.console_internal_port","title":"console_internal_port  <code>instance-attribute</code>","text":"<pre><code>console_internal_port = console_internal_port\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.console_edge_port","title":"console_edge_port  <code>instance-attribute</code>","text":"<pre><code>console_edge_port = console_edge_port or get_available_port()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.minio_root_user","title":"minio_root_user  <code>instance-attribute</code>","text":"<pre><code>minio_root_user = getenv('MINIO_ROOT_USER') or 'minioadmin'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.minio_root_password","title":"minio_root_password  <code>instance-attribute</code>","text":"<pre><code>minio_root_password = getenv('MINIO_ROOT_PASSWORD') or 'minioadmin'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return (\n        \"Minio started: \"\n        f\"S3-API: http://localhost:{self.s3_api_edge_port}/; \"  # noqa: E702\n        f\"console: http://localhost:{self.console_edge_port}/\"\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.get_aws_client_config","title":"get_aws_client_config","text":"<pre><code>get_aws_client_config()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def get_aws_client_config(self) -&gt; AWSClientConfig:\n    return AWSClientConfig(\n        region_name=self.region_name,\n        aws_access_key_id=self.minio_root_user,\n        aws_secret_access_key=self.minio_root_password,\n        endpoint_url=self.get_external_url(),\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MinioContainer.reset_minio","title":"reset_minio","text":"<pre><code>reset_minio()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def reset_minio(self) -&gt; None:\n    self.exec([\"mc\", \"rm\", \"--recursive\", \"--dangerous\", \"--force\", \"data/\"])\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer","title":"MotoContainer","text":"<pre><code>MotoContainer(image='motoserver/moto:latest', internal_port=5000, edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>Moto container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>AWS_ACCESS_KEY_ID</code> - defaults to <code>testing</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code> - defaults to <code>testing</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'motoserver/moto:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"motoserver/moto:latest\",\n    internal_port: int = 5000,\n    edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=\"/moto-api/data.json\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\") or \"testing\"  # nosec: B105\n    self.aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\") or \"testing\"  # nosec: B105\n\n    self.with_env(\"AWS_REGION\", self.region_name)\n    self.with_env(\"AWS_DEFAULT_REGION\", self.region_name)\n    self.with_env(\"AWS_ACCESS_KEY_ID\", self.aws_access_key_id)\n    self.with_env(\"AWS_SECRET_ACCESS_KEY\", self.aws_secret_access_key)\n\n    self.with_env(\"MOTO_PORT\", str(self.internal_port))\n\n    # Docker is needed for running AWS Lambda container\n    self.with_env(\"MOTO_DOCKER_NETWORK_NAME\", self.network)\n    self.with_volume_mapping(\"/var/run/docker.sock\", \"/var/run/docker.sock\")\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id = getenv('AWS_ACCESS_KEY_ID') or 'testing'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key = getenv('AWS_SECRET_ACCESS_KEY') or 'testing'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"Moto dashboard: http://localhost:{self.edge_port}/moto-api\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.get_aws_client_config","title":"get_aws_client_config","text":"<pre><code>get_aws_client_config()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def get_aws_client_config(self) -&gt; AWSClientConfig:\n    return AWSClientConfig(\n        region_name=self.region_name,\n        aws_access_key_id=self.aws_access_key_id,\n        aws_secret_access_key=self.aws_secret_access_key,\n        endpoint_url=self.get_external_url(),\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def start(self) -&gt; \"MotoContainer\":\n    super().start()\n    wait_for_logs(self, \"Running on all addresses\", timeout=10.0)\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MotoContainer.reset_moto","title":"reset_moto","text":"<pre><code>reset_moto()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def reset_moto(self) -&gt; None:\n    self.exec([\"curl\", \"-X\", \"POST\", f\"http://localhost:{self.internal_port}/moto-api/reset\"])\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.TomodachiContainer","title":"TomodachiContainer","text":"<pre><code>TomodachiContainer(image, internal_port=9700, edge_port=None, http_healthcheck_path=None, *, export_coverage=False, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>Tomodachi container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE</code> - defaults to <code>False</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>9700</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>http_healthcheck_path</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>export_coverage</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def __init__(\n    self,\n    image: str,\n    internal_port: int = 9700,\n    edge_port: Optional[int] = None,\n    http_healthcheck_path: Optional[str] = None,\n    *,\n    export_coverage: bool = False,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image=image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=http_healthcheck_path,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n    self._export_coverage = export_coverage or bool(os.getenv(\"TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE\"))\n    if self._export_coverage:\n        self._configure_coverage_export()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.TomodachiContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"Tomodachi service: http://localhost:{self.edge_port}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.TomodachiContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def start(self) -&gt; \"TomodachiContainer\":\n    super().start()\n    # Apart from HTTP healthcheck, we need to wait for \"started service\" log\n    # to make sure messaging transport like AWS SNS SQS is also up and running.\n    # It's started independently from HTTP transport.\n\n    # Different service start messages depending on tomodachi version\n    # tomodachi &lt; 0.26.0 - \"Started service\"\n    # tomodachi &gt;= 0.26.0 - \"started service successfully\"\n    # using (?i) to ignore case to support both versions\n    wait_for_logs(self, \"(?i)started service\", timeout=10.0)\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.TomodachiContainer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def stop(self) -&gt; None:\n    if self._export_coverage:\n        with suppress(Exception):\n            self._stop_container_and_copy_coverage_report()\n    super().stop()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer","title":"WireMockContainer","text":"<pre><code>WireMockContainer(image='wiremock/wiremock:latest', internal_port=8080, edge_port=None, mapping_stubs=None, mapping_files=None, *, verbose=False, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'wiremock/wiremock:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>8080</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>mapping_stubs</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>mapping_files</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"wiremock/wiremock:latest\",\n    internal_port: int = 8080,\n    edge_port: Optional[int] = None,\n    mapping_stubs: Optional[Path] = None,\n    mapping_files: Optional[Path] = None,\n    *,\n    verbose: bool = False,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    mapping_stubs_env = os.getenv(\"WIREMOCK_TESTCONTAINER_MAPPING_STUBS\")\n    mapping_files_env = os.getenv(\"WIREMOCK_TESTCONTAINER_MAPPING_FILES\")\n\n    self.mapping_stubs = mapping_stubs or (Path(mapping_stubs_env) if mapping_stubs_env else None)\n    self.mapping_files = mapping_files or (Path(mapping_files_env) if mapping_files_env else None)\n\n    if verbose or os.getenv(\"WIREMOCK_TESTCONTAINER_VERBOSE\"):\n        self.with_command(\"--verbose\")\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.MAPPING_STUBS_DIR","title":"MAPPING_STUBS_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAPPING_STUBS_DIR = Path('/home/wiremock/mappings/')\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.MAPPING_FILES_DIR","title":"MAPPING_FILES_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAPPING_FILES_DIR = Path('/home/wiremock/__files/')\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.mapping_stubs","title":"mapping_stubs  <code>instance-attribute</code>","text":"<pre><code>mapping_stubs = mapping_stubs or Path(mapping_stubs_env) if mapping_stubs_env else None\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.mapping_files","title":"mapping_files  <code>instance-attribute</code>","text":"<pre><code>mapping_files = mapping_files or Path(mapping_files_env) if mapping_files_env else None\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"Wiremock admin: http://localhost:{self.edge_port}/__admin\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def start(self) -&gt; \"WireMockContainer\":\n    super().start()\n    wait_for_logs(self, \"port:\", timeout=10.0)\n    self.load_mappings_from_files()\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.load_mappings_from_files","title":"load_mappings_from_files","text":"<pre><code>load_mappings_from_files()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def load_mappings_from_files(self) -&gt; None:\n    self._copy_mapping_stubs_to_container()\n    self._copy_mapping_files_to_container()\n    self.reset_mappings()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.delete_mappings","title":"delete_mappings","text":"<pre><code>delete_mappings()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def delete_mappings(self) -&gt; None:\n    self.exec([\"curl\", \"-X\", \"DELETE\", f\"http://localhost:{self.internal_port}/__admin/mappings\"])\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.WireMockContainer.reset_mappings","title":"reset_mappings","text":"<pre><code>reset_mappings()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def reset_mappings(self) -&gt; None:\n    self.exec([\"curl\", \"-X\", \"POST\", f\"http://localhost:{self.internal_port}/__admin/mappings/reset\"])\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer","title":"DatabaseContainer","text":"<pre><code>DatabaseContainer(image, internal_port, edge_port=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code>, <code>ABC</code></p> <p>Abstract class for relational database containers.</p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def __init__(\n    self,\n    image: str,\n    internal_port: int,\n    edge_port: Optional[int] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(image, disable_logging=disable_logging, **kwargs)\n    self.internal_port = internal_port\n    self.edge_port = edge_port or get_available_port()\n    self.with_bind_ports(internal_port, self.edge_port)\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.internal_port","title":"internal_port  <code>instance-attribute</code>","text":"<pre><code>internal_port = internal_port\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.edge_port","title":"edge_port  <code>instance-attribute</code>","text":"<pre><code>edge_port = edge_port or get_available_port()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.drivername","title":"drivername  <code>instance-attribute</code>","text":"<pre><code>drivername\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.database","title":"database  <code>instance-attribute</code>","text":"<pre><code>database\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.get_internal_url","title":"get_internal_url","text":"<pre><code>get_internal_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def get_internal_url(self) -&gt; DatabaseURL:\n    return DatabaseURL(\n        drivername=self.drivername,\n        username=self.username,\n        password=self.password,\n        host=self.get_container_internal_ip(),\n        port=self.internal_port,\n        database=self.database,\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.get_external_url","title":"get_external_url","text":"<pre><code>get_external_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def get_external_url(self) -&gt; DatabaseURL:\n    return DatabaseURL(\n        drivername=self.drivername,\n        username=self.username,\n        password=self.password,\n        host=self.get_container_host_ip(),\n        port=self.edge_port,\n        database=self.database,\n    )\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.DatabaseContainer.start","title":"start","text":"<pre><code>start(timeout=20.0)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>20.0</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def start(self, timeout: float = 20.0) -&gt; \"DatabaseContainer\":\n    super().start()\n    wait_for_database_healthcheck(url=self.get_external_url(), timeout=timeout)\n    return self\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer","title":"MySQLContainer","text":"<pre><code>MySQLContainer(image='mysql:8', internal_port=3306, edge_port=None, drivername=None, username=None, root_password=None, password=None, database=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DatabaseContainer</code></p> <p>MySQL container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>MYSQL_DRIVERNAME</code> - defaults to <code>mysql+pymysql</code></li> <li><code>MYSQL_USER</code> - defaults to <code>username</code></li> <li><code>MYSQL_ROOT_PASSWORD</code> - defaults to <code>root</code></li> <li><code>MYSQL_PASSWORD</code> - defaults to <code>password</code></li> <li><code>MYSQL_DATABASE</code> - defaults to <code>db</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'mysql:8'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>3306</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>drivername</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>username</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>root_password</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>password</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>database</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/mysql.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"mysql:8\",\n    internal_port: int = 3306,\n    edge_port: Optional[int] = None,\n    drivername: Optional[str] = None,\n    username: Optional[str] = None,\n    root_password: Optional[str] = None,\n    password: Optional[str] = None,\n    database: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.drivername = drivername or os.getenv(\"MYSQL_DRIVERNAME\") or \"mysql+pymysql\"\n    self.username = username or os.getenv(\"MYSQL_USER\") or \"username\"\n    self.root_password = root_password or os.getenv(\"MYSQL_ROOT_PASSWORD\") or \"root\"\n    self.password = password or os.getenv(\"MYSQL_PASSWORD\") or \"password\"\n    self.database = database or os.getenv(\"MYSQL_DATABASE\") or \"db\"\n\n    if self.username == \"root\":\n        self.root_password = self.password\n\n    self.with_env(\"MYSQL_USER\", self.username)\n    self.with_env(\"MYSQL_ROOT_PASSWORD\", self.root_password)\n    self.with_env(\"MYSQL_PASSWORD\", self.password)\n    self.with_env(\"MYSQL_DATABASE\", self.database)\n\n    # Do not flush data on disk to improve test container performance\n    # https://pythonspeed.com/articles/faster-db-tests/\n    self.with_command(\"--innodb_flush_method=O_DIRECT_NO_FSYNC\")\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer.drivername","title":"drivername  <code>instance-attribute</code>","text":"<pre><code>drivername = drivername or getenv('MYSQL_DRIVERNAME') or 'mysql+pymysql'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username or getenv('MYSQL_USER') or 'username'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer.root_password","title":"root_password  <code>instance-attribute</code>","text":"<pre><code>root_password = root_password or getenv('MYSQL_ROOT_PASSWORD') or 'root'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password or getenv('MYSQL_PASSWORD') or 'password'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer.database","title":"database  <code>instance-attribute</code>","text":"<pre><code>database = database or getenv('MYSQL_DATABASE') or 'db'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.MySQLContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/mysql.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"MySQL started: {self.get_external_url()}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.PostgreSQLContainer","title":"PostgreSQLContainer","text":"<pre><code>PostgreSQLContainer(image='postgres:16', internal_port=5432, edge_port=None, drivername=None, username=None, password=None, database=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DatabaseContainer</code></p> <p>PostgreSQL container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>POSTGRES_DRIVERNAME</code> - defaults to <code>postgresql+psycopg</code></li> <li><code>POSTGRES_USER</code> - defaults to <code>username</code></li> <li><code>POSTGRES_PASSWORD</code> - defaults to <code>password</code></li> <li><code>POSTGRES_DB</code> - defaults to <code>db</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'postgres:16'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>5432</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>drivername</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>username</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>password</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>database</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/postgres.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"postgres:16\",\n    internal_port: int = 5432,\n    edge_port: Optional[int] = None,\n    drivername: Optional[str] = None,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    database: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.drivername = drivername or os.getenv(\"POSTGRES_DRIVERNAME\") or \"postgresql+psycopg\"\n    self.username = username or os.getenv(\"POSTGRES_USER\") or \"username\"\n    self.password = password or os.getenv(\"POSTGRES_PASSWORD\") or \"password\"\n    self.database = database or os.getenv(\"POSTGRES_DB\") or \"db\"\n\n    self.with_env(\"POSTGRES_USER\", self.username)\n    self.with_env(\"POSTGRES_PASSWORD\", self.password)\n    self.with_env(\"POSTGRES_DB\", self.database)\n\n    # Do not flush data on disk to improve test container performance\n    # https://pythonspeed.com/articles/faster-db-tests/\n    self.with_command(\"-c fsync=off\")\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.PostgreSQLContainer.drivername","title":"drivername  <code>instance-attribute</code>","text":"<pre><code>drivername = drivername or getenv('POSTGRES_DRIVERNAME') or 'postgresql+psycopg'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.PostgreSQLContainer.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username or getenv('POSTGRES_USER') or 'username'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.PostgreSQLContainer.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password or getenv('POSTGRES_PASSWORD') or 'password'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.PostgreSQLContainer.database","title":"database  <code>instance-attribute</code>","text":"<pre><code>database = database or getenv('POSTGRES_DB') or 'db'\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.PostgreSQLContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/postgres.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"PostgreSQL started: {self.get_external_url()}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer","title":"SFTPContainer","text":"<pre><code>SFTPContainer(image='atmoz/sftp:latest', internal_port=22, edge_port=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code></p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'atmoz/sftp:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>22</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"atmoz/sftp:latest\",\n    internal_port: int = 22,\n    edge_port: Optional[int] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(image, disable_logging=disable_logging, **kwargs)\n    self.internal_port = internal_port\n    self.edge_port = edge_port or get_available_port()\n    self.with_bind_ports(self.internal_port, self.edge_port)\n\n    self.with_command(\"userpass:pass:1001 userssh::1002\")\n\n    self.authorized_private_key = asyncssh.generate_private_key(\"ssh-ed25519\")\n    self.authorized_public_key = self.authorized_private_key.export_public_key().decode()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.internal_port","title":"internal_port  <code>instance-attribute</code>","text":"<pre><code>internal_port = internal_port\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.edge_port","title":"edge_port  <code>instance-attribute</code>","text":"<pre><code>edge_port = edge_port or get_available_port()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.authorized_private_key","title":"authorized_private_key  <code>instance-attribute</code>","text":"<pre><code>authorized_private_key = generate_private_key('ssh-ed25519')\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.authorized_public_key","title":"authorized_public_key  <code>instance-attribute</code>","text":"<pre><code>authorized_public_key = decode()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"SFTP server running on port: {self.edge_port}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.get_internal_conn_details","title":"get_internal_conn_details","text":"<pre><code>get_internal_conn_details()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_internal_conn_details(self) -&gt; ConnectionDetails:\n    host = self.get_container_internal_ip()\n    return ConnectionDetails(host=host, port=self.internal_port)\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.get_external_conn_details","title":"get_external_conn_details","text":"<pre><code>get_external_conn_details()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_external_conn_details(self) -&gt; ConnectionDetails:\n    host = self.get_container_host_ip()\n    return ConnectionDetails(host=host, port=self.edge_port)\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.get_host_public_key","title":"get_host_public_key","text":"<pre><code>get_host_public_key()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_host_public_key(self) -&gt; str:\n    _, output = self.exec(\"bash -c 'cat /etc/ssh/ssh_host_ed25519_key.pub'\")\n    return bytes(output).decode().strip()\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.get_internal_known_host","title":"get_internal_known_host","text":"<pre><code>get_internal_known_host()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_internal_known_host(self) -&gt; str:\n    internal = self.get_internal_conn_details()\n    public_key = self.get_host_public_key()\n    return f\"{internal.host} {public_key}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.get_external_known_host","title":"get_external_known_host","text":"<pre><code>get_external_known_host()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_external_known_host(self) -&gt; str:\n    external = self.get_external_conn_details()\n    public_key = self.get_host_public_key()\n    return f\"{external.host} {public_key}\"\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.get_known_hosts","title":"get_known_hosts","text":"<pre><code>get_known_hosts()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_known_hosts(self) -&gt; asyncssh.SSHKnownHosts:\n    known_hosts = asyncssh.SSHKnownHosts()\n    for known_host in (self.get_internal_known_host(), self.get_external_known_host()):\n        known_hosts.load(known_host)\n    return known_hosts\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.add_authorized_key","title":"add_authorized_key","text":"<pre><code>add_authorized_key(username, uid, gid, public_key)\n</code></pre> PARAMETER DESCRIPTION <code>username</code> <p> TYPE: <code>str</code> </p> <code>uid</code> <p> TYPE: <code>str</code> </p> <code>gid</code> <p> TYPE: <code>str</code> </p> <code>public_key</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def add_authorized_key(self, username: str, uid: str, gid: str, public_key: str) -&gt; None:\n    self.exec(f\"bash -c 'mkdir -p /home/{username}/.ssh'\")\n    self.exec(f\"bash -c 'chmod 700 /home/{username}/.ssh'\")\n    self.exec(f\"bash -c 'touch /home/{username}/.ssh/authorized_keys'\")\n    self.exec(f\"bash -c 'chmod 600 /home/{username}/.ssh/authorized_keys'\")\n    self.exec(f\"bash -c 'echo \\\"{public_key}\\\" &gt;&gt; /home/{username}/.ssh/authorized_keys'\")\n    self.exec(f\"bash -c 'chown -R {uid}:{gid} /home/{username}/.ssh'\")\n</code></pre>"},{"location":"reference/#tomodachi_testcontainers.SFTPContainer.start","title":"start","text":"<pre><code>start(timeout=10.0)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>10.0</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def start(self, timeout: float = 10.0) -&gt; \"SFTPContainer\":\n    super().start()\n    wait_for_logs(self, r\"Server listening on\", timeout=timeout)\n\n    self.exec(\"bash -c 'mkdir /home/userpass/upload &amp;&amp; chown -R 1001:1001 /home/userpass/upload'\")\n    self.exec(\"bash -c 'mkdir /home/userpass/download &amp;&amp; chown -R 1001:1001 /home/userpass/download'\")\n    self.exec(\"bash -c 'mkdir /home/userssh/upload &amp;&amp; chown -R 1002:1002 /home/userssh/upload'\")\n    self.exec(\"bash -c 'mkdir /home/userssh/download &amp;&amp; chown -R 1002:1002 /home/userssh/download'\")\n\n    self.add_authorized_key(username=\"userssh\", uid=\"1002\", gid=\"1002\", public_key=self.authorized_public_key)\n\n    return self\n</code></pre>"},{"location":"reference/assertions/","title":"Assertions","text":""},{"location":"reference/assertions/#tomodachi_testcontainers.assertions","title":"tomodachi_testcontainers.assertions","text":""},{"location":"reference/assertions/#tomodachi_testcontainers.assertions.DEFAULT_DATETIME_RANGE","title":"DEFAULT_DATETIME_RANGE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_DATETIME_RANGE = timedelta(seconds=10)\n</code></pre>"},{"location":"reference/assertions/#tomodachi_testcontainers.assertions.assert_datetime_within_range","title":"assert_datetime_within_range","text":"<pre><code>assert_datetime_within_range(value, range=DEFAULT_DATETIME_RANGE)\n</code></pre> PARAMETER DESCRIPTION <code>value</code> <p> TYPE: <code>datetime</code> </p> <code>range</code> <p> TYPE: <code>timedelta</code> DEFAULT: <code>DEFAULT_DATETIME_RANGE</code> </p> Source code in <code>src/tomodachi_testcontainers/assertions.py</code> <pre><code>def assert_datetime_within_range(value: datetime, range: timedelta = DEFAULT_DATETIME_RANGE) -&gt; None:\n    current_datetime = datetime.now(timezone.utc)\n    start_datetime = current_datetime - range\n    end_datetime = current_datetime + range\n    assert start_datetime &lt;= value &lt;= end_datetime  # nosec: B101\n</code></pre>"},{"location":"reference/assertions/#tomodachi_testcontainers.assertions.assert_logs_contain","title":"assert_logs_contain","text":"<pre><code>assert_logs_contain(container, contains)\n</code></pre> PARAMETER DESCRIPTION <code>container</code> <p> TYPE: <code>DockerContainer</code> </p> <code>contains</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/assertions.py</code> <pre><code>def assert_logs_contain(container: DockerContainer, contains: str) -&gt; None:\n    stdout_and_stderr_logs = cast(Tuple[bytes, bytes], container.get_logs())\n    for log in stdout_and_stderr_logs:\n        if contains in log.decode():\n            return\n    raise AssertionError(f\"Expected logs to contain: '{contains}'; logs: {stdout_and_stderr_logs}\")  # noqa: E702\n</code></pre>"},{"location":"reference/assertions/#tomodachi_testcontainers.assertions.assert_logs_not_contain","title":"assert_logs_not_contain","text":"<pre><code>assert_logs_not_contain(container, contains)\n</code></pre> PARAMETER DESCRIPTION <code>container</code> <p> TYPE: <code>DockerContainer</code> </p> <code>contains</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/assertions.py</code> <pre><code>def assert_logs_not_contain(container: DockerContainer, contains: str) -&gt; None:\n    stdout_and_stderr_logs = cast(Tuple[bytes, bytes], container.get_logs())\n    for log in stdout_and_stderr_logs:\n        if contains in log.decode():\n            raise AssertionError(\n                f\"Expected logs not to contain: '{contains}'; logs: {stdout_and_stderr_logs}\"  # noqa: E702\n            )\n</code></pre>"},{"location":"reference/assertions/#tomodachi_testcontainers.assertions.assert_logs_match_line_count","title":"assert_logs_match_line_count","text":"<pre><code>assert_logs_match_line_count(container, contains, count)\n</code></pre> PARAMETER DESCRIPTION <code>container</code> <p> TYPE: <code>DockerContainer</code> </p> <code>contains</code> <p> TYPE: <code>str</code> </p> <code>count</code> <p> TYPE: <code>int</code> </p> Source code in <code>src/tomodachi_testcontainers/assertions.py</code> <pre><code>def assert_logs_match_line_count(container: DockerContainer, contains: str, count: int) -&gt; None:\n    stdout_logs = cast(bytes, container.get_logs()[0])\n    stderr_logs = cast(bytes, container.get_logs()[1])\n    stdout_and_stderr_logs = \"\\n\".join([stdout_logs.decode(), stderr_logs.decode()])\n\n    matched_lines = [log for log in stdout_and_stderr_logs.splitlines() if contains in log]\n    error_msg = (\n        f\"Expected '{contains}' to be contained in {count} lines, found {len(matched_lines)} lines\"  # noqa: E702\n        f\"; logs: {stdout_and_stderr_logs}\"  # noqa: E702\n    )\n    assert len(matched_lines) == count, error_msg  # nosec: B101\n</code></pre>"},{"location":"reference/async-probes/","title":"Async Probes","text":""},{"location":"reference/async-probes/#tomodachi_testcontainers.async_probes","title":"tomodachi_testcontainers.async_probes","text":"<p>Asynchronous probes (sampling) for testing asynchronous systems.</p> <p>Inspired by Awaitility and busypie.</p>"},{"location":"reference/async-probes/#tomodachi_testcontainers.async_probes.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"reference/async-probes/#tomodachi_testcontainers.async_probes.probe_until","title":"probe_until  <code>async</code>","text":"<pre><code>probe_until(probe: Callable[[], Awaitable[T]], probe_interval: float = 0.1, stop_after: float = 3.0) -&gt; T\n</code></pre><pre><code>probe_until(probe: Callable[[], T], probe_interval: float = 0.1, stop_after: float = 3.0) -&gt; T\n</code></pre> <pre><code>probe_until(probe, probe_interval=0.1, stop_after=3.0)\n</code></pre> <p>Run given function until it finishes without exceptions.</p> <p>Given function can be a regular synchronous function or an asynchronous function.</p> PARAMETER DESCRIPTION <code>probe</code> <p> TYPE: <code>Union[Callable[[], Awaitable[T]], Callable[[], T]]</code> </p> <code>probe_interval</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>stop_after</code> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> Source code in <code>src/tomodachi_testcontainers/async_probes.py</code> <pre><code>async def probe_until(\n    probe: Union[Callable[[], Awaitable[T]], Callable[[], T]],\n    probe_interval: float = 0.1,\n    stop_after: float = 3.0,\n) -&gt; T:\n    \"\"\"Run given function until it finishes without exceptions.\n\n    Given function can be a regular synchronous function or an asynchronous function.\n    \"\"\"\n    result: Any = None\n    async for attempt in AsyncRetrying(\n        wait=wait_fixed(probe_interval),\n        stop=stop_after_delay(stop_after),\n        reraise=True,\n    ):\n        with attempt:\n            result = probe()\n            if asyncio.iscoroutine(result):\n                result = await result\n    return cast(T, result)\n</code></pre>"},{"location":"reference/async-probes/#tomodachi_testcontainers.async_probes.probe_during_interval","title":"probe_during_interval  <code>async</code>","text":"<pre><code>probe_during_interval(probe: Callable[[], Awaitable[T]], probe_interval: float = 0.1, stop_after: float = 3.0) -&gt; T\n</code></pre><pre><code>probe_during_interval(probe: Callable[[], T], probe_interval: float = 0.1, stop_after: float = 3.0) -&gt; T\n</code></pre> <pre><code>probe_during_interval(probe, probe_interval=0.1, stop_after=3.0)\n</code></pre> <p>Run given function until timeout is reached and the function always finishes without exceptions.</p> <p>Given function can be a regular synchronous function or an asynchronous function.</p> PARAMETER DESCRIPTION <code>probe</code> <p> TYPE: <code>Callable[[], Union[Awaitable[T], T]]</code> </p> <code>probe_interval</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.1</code> </p> <code>stop_after</code> <p> TYPE: <code>float</code> DEFAULT: <code>3.0</code> </p> Source code in <code>src/tomodachi_testcontainers/async_probes.py</code> <pre><code>async def probe_during_interval(\n    probe: Callable[[], Union[Awaitable[T], T]],\n    probe_interval: float = 0.1,\n    stop_after: float = 3.0,\n) -&gt; T:\n    \"\"\"Run given function until timeout is reached and the function always finishes without exceptions.\n\n    Given function can be a regular synchronous function or an asynchronous function.\n    \"\"\"\n    result: Any = None\n    with suppress(RetryError):\n        async for attempt in AsyncRetrying(\n            wait=wait_fixed(probe_interval),\n            stop=stop_after_delay(stop_after),\n            retry=retry_unless_exception_type(BaseException),\n            reraise=True,\n        ):\n            with attempt:\n                result = probe()\n                if asyncio.iscoroutine(result):\n                    result = await result\n    return cast(T, result)\n</code></pre>"},{"location":"reference/clients/","title":"Clients module","text":""},{"location":"reference/clients/#tomodachi_testcontainers.clients","title":"tomodachi_testcontainers.clients","text":"<p>Test clients for testing interactions with external systems, like AWS SNS/SQS.</p>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient","title":"SNSSQSTestClient","text":"<pre><code>SNSSQSTestClient(sns_client, sqs_client)\n</code></pre> <p>Provides common methods for testing AWS SNS/SQS interactions with Tomodachi framework.</p> PARAMETER DESCRIPTION <code>sns_client</code> <p> TYPE: <code>SNSClient</code> </p> <code>sqs_client</code> <p> TYPE: <code>SQSClient</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>def __init__(self, sns_client: SNSClient, sqs_client: SQSClient) -&gt; None:\n    self._sns_client = sns_client\n    self._sqs_client = sqs_client\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.create_topic","title":"create_topic  <code>async</code>","text":"<pre><code>create_topic(topic)\n</code></pre> PARAMETER DESCRIPTION <code>topic</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def create_topic(self, topic: str) -&gt; TopicARNType:\n    with suppress(TopicDoesNotExistError):\n        return await self.get_topic_arn(topic)\n    topic_attributes: Dict[str, str] = {}\n    if topic.endswith(\".fifo\"):\n        topic_attributes.update(\n            {\n                \"FifoTopic\": \"true\",\n                \"ContentBasedDeduplication\": \"false\",\n            }\n        )\n    create_topic_response = await self._sns_client.create_topic(Name=topic, Attributes=topic_attributes)\n    return create_topic_response[\"TopicArn\"]\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.create_queue","title":"create_queue  <code>async</code>","text":"<pre><code>create_queue(queue)\n</code></pre> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def create_queue(self, queue: str) -&gt; QueueARNType:\n    with suppress(QueueDoesNotExistError):\n        return await self.get_queue_arn(queue)\n    queue_attributes: Dict[QueueAttributeNameType, str] = {}\n    if queue.endswith(\".fifo\"):\n        queue_attributes.update(\n            {\n                \"FifoQueue\": \"true\",\n                \"ContentBasedDeduplication\": \"false\",\n            }\n        )\n    await self._sqs_client.create_queue(QueueName=queue, Attributes=queue_attributes)\n    queue_attributes = await self.get_queue_attributes(queue, attributes=[\"QueueArn\"])\n    return queue_attributes[\"QueueArn\"]\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.subscribe_to","title":"subscribe_to  <code>async</code>","text":"<pre><code>subscribe_to(topic, queue, subscribe_attributes=None)\n</code></pre> <p>Subscribe a SQS queue to a SNS topic; create the topic and queue if they don't exist.</p> PARAMETER DESCRIPTION <code>topic</code> <p> TYPE: <code>str</code> </p> <code>queue</code> <p> TYPE: <code>str</code> </p> <code>subscribe_attributes</code> <p> TYPE: <code>Optional[Dict[str, str]]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def subscribe_to(\n    self,\n    topic: str,\n    queue: str,\n    subscribe_attributes: Optional[Dict[str, str]] = None,\n) -&gt; None:\n    \"\"\"Subscribe a SQS queue to a SNS topic; create the topic and queue if they don't exist.\"\"\"\n    topic_arn = await self.create_topic(topic)\n    queue_arn = await self.create_queue(queue)\n    await self._sns_client.subscribe(\n        TopicArn=topic_arn,\n        Protocol=\"sqs\",\n        Endpoint=queue_arn,\n        Attributes=subscribe_attributes or {},\n    )\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.receive","title":"receive  <code>async</code>","text":"<pre><code>receive(queue, envelope, message_type, max_messages=10)\n</code></pre> <p>Receive messages from SQS queue.</p> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> <code>envelope</code> <p> TYPE: <code>TomodachiSNSSQSEnvelope</code> </p> <code>message_type</code> <p> TYPE: <code>Type[MessageType]</code> </p> <code>max_messages</code> <p> TYPE: <code>int</code> DEFAULT: <code>10</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def receive(\n    self,\n    queue: str,\n    envelope: TomodachiSNSSQSEnvelope,\n    message_type: Type[MessageType],\n    max_messages: int = 10,\n) -&gt; List[SQSMessage[MessageType]]:\n    \"\"\"Receive messages from SQS queue.\"\"\"\n    queue_url = await self.get_queue_url(queue)\n    received_messages_response = await self._sqs_client.receive_message(\n        QueueUrl=queue_url, MaxNumberOfMessages=max_messages, MessageAttributeNames=[\"All\"]\n    )\n    sqs_messages: List[SQSMessage[MessageType]] = []\n    for received_message in received_messages_response.get(\"Messages\", []):\n        payload = await self._parse_received_message_payload(envelope, message_type, received_message)\n        message_attributes = self._parse_received_message_attributes(received_message)\n        sqs_messages.append(SQSMessage(payload, message_attributes))\n        await self._sqs_client.delete_message(QueueUrl=queue_url, ReceiptHandle=received_message[\"ReceiptHandle\"])\n    return sqs_messages\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.publish","title":"publish  <code>async</code>","text":"<pre><code>publish(topic, data, envelope, message_attributes=None, message_deduplication_id=None, message_group_id=None)\n</code></pre> <p>Publish message to SNS topic.</p> PARAMETER DESCRIPTION <code>topic</code> <p> TYPE: <code>str</code> </p> <code>data</code> <p> TYPE: <code>Any</code> </p> <code>envelope</code> <p> TYPE: <code>TomodachiSNSSQSEnvelope</code> </p> <code>message_attributes</code> <p> TYPE: <code>Optional[Dict[str, MessageAttributeValueTypeDef]]</code> DEFAULT: <code>None</code> </p> <code>message_deduplication_id</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>message_group_id</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def publish(\n    self,\n    topic: str,\n    data: Any,\n    envelope: TomodachiSNSSQSEnvelope,\n    message_attributes: Optional[Dict[str, SNSMessageAttributeValueTypeDef]] = None,\n    message_deduplication_id: Optional[str] = None,\n    message_group_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Publish message to SNS topic.\"\"\"\n    topic_arn = await self.get_topic_arn(topic)\n    message = await envelope.build_message(service={}, topic=topic, data=data)\n    sns_publish_kwargs: Dict[str, Any] = {}\n    if message_attributes:\n        sns_publish_kwargs[\"MessageAttributes\"] = message_attributes\n    if message_deduplication_id:\n        sns_publish_kwargs[\"MessageDeduplicationId\"] = message_deduplication_id\n    if message_group_id:\n        sns_publish_kwargs[\"MessageGroupId\"] = message_group_id\n    await self._sns_client.publish(TopicArn=topic_arn, Message=message, **sns_publish_kwargs)\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.send","title":"send  <code>async</code>","text":"<pre><code>send(queue, data, envelope, message_attributes=None, message_deduplication_id=None, message_group_id=None)\n</code></pre> <p>Send message to SQS queue.</p> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> <code>data</code> <p> TYPE: <code>Any</code> </p> <code>envelope</code> <p> TYPE: <code>TomodachiSNSSQSEnvelope</code> </p> <code>message_attributes</code> <p> TYPE: <code>Optional[Dict[str, MessageAttributeValueTypeDef]]</code> DEFAULT: <code>None</code> </p> <code>message_deduplication_id</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>message_group_id</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def send(\n    self,\n    queue: str,\n    data: Any,\n    envelope: TomodachiSNSSQSEnvelope,\n    message_attributes: Optional[Dict[str, SQSMessageAttributeValueTypeDef]] = None,\n    message_deduplication_id: Optional[str] = None,\n    message_group_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Send message to SQS queue.\"\"\"\n    queue_url = await self.get_queue_url(queue)\n    message = await envelope.build_message(service={}, topic=\"\", data=data)\n    sqs_send_kwargs: Dict[str, Any] = {}\n    if message_attributes:\n        sqs_send_kwargs[\"MessageAttributes\"] = message_attributes\n    if message_deduplication_id:\n        sqs_send_kwargs[\"MessageDeduplicationId\"] = message_deduplication_id\n    if message_group_id:\n        sqs_send_kwargs[\"MessageGroupId\"] = message_group_id\n    await self._sqs_client.send_message(\n        QueueUrl=queue_url, MessageBody=json.dumps({\"Message\": message}), **sqs_send_kwargs\n    )\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.get_topic_arn","title":"get_topic_arn  <code>async</code>","text":"<pre><code>get_topic_arn(topic)\n</code></pre> PARAMETER DESCRIPTION <code>topic</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def get_topic_arn(self, topic: str) -&gt; str:\n    list_topics_response = await self._sns_client.list_topics()\n    topic_arn = next((v[\"TopicArn\"] for v in list_topics_response[\"Topics\"] if v[\"TopicArn\"].endswith(topic)), None)\n    if not topic_arn:\n        raise TopicDoesNotExistError(topic)\n    return topic_arn\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.get_topic_attributes","title":"get_topic_attributes  <code>async</code>","text":"<pre><code>get_topic_attributes(topic)\n</code></pre> PARAMETER DESCRIPTION <code>topic</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def get_topic_attributes(self, topic: str) -&gt; Dict[str, str]:\n    topic_arn = await self.get_topic_arn(topic)\n    get_topic_attributes_response = await self._sns_client.get_topic_attributes(TopicArn=topic_arn)\n    return get_topic_attributes_response[\"Attributes\"]\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.get_queue_arn","title":"get_queue_arn  <code>async</code>","text":"<pre><code>get_queue_arn(queue)\n</code></pre> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def get_queue_arn(self, queue: str) -&gt; str:\n    attributes = await self.get_queue_attributes(queue, attributes=[\"QueueArn\"])\n    return attributes[\"QueueArn\"]\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.get_queue_url","title":"get_queue_url  <code>async</code>","text":"<pre><code>get_queue_url(queue)\n</code></pre> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def get_queue_url(self, queue: str) -&gt; str:\n    try:\n        get_queue_response = await self._sqs_client.get_queue_url(QueueName=queue)\n        return get_queue_response[\"QueueUrl\"]\n    except ClientError as e:\n        raise QueueDoesNotExistError(queue) from e\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.get_queue_attributes","title":"get_queue_attributes  <code>async</code>","text":"<pre><code>get_queue_attributes(queue, attributes)\n</code></pre> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> <code>attributes</code> <p> TYPE: <code>List[QueueAttributeFilterType]</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def get_queue_attributes(\n    self, queue: str, attributes: List[QueueAttributeFilterType]\n) -&gt; Dict[QueueAttributeNameType, str]:\n    queue_url = await self.get_queue_url(queue)\n    get_queue_attributes_response = await self._sqs_client.get_queue_attributes(\n        QueueUrl=queue_url, AttributeNames=attributes\n    )\n    return get_queue_attributes_response[\"Attributes\"]\n</code></pre>"},{"location":"reference/clients/#tomodachi_testcontainers.clients.SNSSQSTestClient.purge_queue","title":"purge_queue  <code>async</code>","text":"<pre><code>purge_queue(queue)\n</code></pre> <p>Delete all messages from SQS queue.</p> PARAMETER DESCRIPTION <code>queue</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/clients/snssqs.py</code> <pre><code>async def purge_queue(self, queue: str) -&gt; None:\n    \"\"\"Delete all messages from SQS queue.\"\"\"\n    queue_url = await self.get_queue_url(queue)\n    await self._sqs_client.purge_queue(QueueUrl=queue_url)\n</code></pre>"},{"location":"reference/containers/","title":"Containers","text":""},{"location":"reference/containers/#tomodachi_testcontainers","title":"tomodachi_testcontainers","text":""},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer","title":"DockerContainer","text":"<pre><code>DockerContainer(*args, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code>, <code>ABC</code></p> <p>Abstract class for generic Docker containers.</p> PARAMETER DESCRIPTION <code>*args</code> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def __init__(self, *args: Any, disable_logging: bool = False, **kwargs: Any) -&gt; None:\n    self._set_container_network()\n\n    super().__init__(*args, **kwargs, network=self.network)\n\n    self._set_default_container_name()\n\n    self._disable_logging = disable_logging\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.log_message_on_container_start","title":"log_message_on_container_start  <code>abstractmethod</code>","text":"<pre><code>log_message_on_container_start()\n</code></pre> <p>Returns a message that will be logged when the container starts.</p> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>@abc.abstractmethod\ndef log_message_on_container_start(self) -&gt; str:\n    \"\"\"Returns a message that will be logged when the container starts.\"\"\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.get_container_internal_ip","title":"get_container_internal_ip","text":"<pre><code>get_container_internal_ip()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def get_container_internal_ip(self) -&gt; str:\n    return self.docker_inspect()[\"NetworkSettings\"][\"Networks\"][self.network][\"IPAddress\"]\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.get_container_gateway_ip","title":"get_container_gateway_ip","text":"<pre><code>get_container_gateway_ip()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def get_container_gateway_ip(self) -&gt; str:\n    return self.docker_inspect()[\"NetworkSettings\"][\"Networks\"][self.network][\"Gateway\"]\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.docker_inspect","title":"docker_inspect","text":"<pre><code>docker_inspect()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def docker_inspect(self) -&gt; Dict[str, Any]:\n    return self.get_docker_client().get_container(self.get_wrapped_container().id)\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def start(self) -&gt; \"DockerContainer\":\n    self._setup_logger()\n    self._start()\n    self._log_message_on_container_start()\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def stop(self) -&gt; None:\n    with suppress(Exception):\n        container = self._container or cast(Container, self.get_docker_client().client.containers.get(self._name))\n        container.remove(force=True, v=True)\n    self._container = None\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DockerContainer.restart","title":"restart","text":"<pre><code>restart()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/container.py</code> <pre><code>def restart(self) -&gt; None:\n    self.get_wrapped_container().restart()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.EphemeralDockerImage","title":"EphemeralDockerImage","text":"<pre><code>EphemeralDockerImage(dockerfile=None, context=None, target=None, docker_client_kwargs=None, *, remove_image_on_exit=True)\n</code></pre> <p>Builds a Docker image from a given Dockerfile and removes it when the context manager exits.</p> PARAMETER DESCRIPTION <code>dockerfile</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>context</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>target</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>docker_client_kwargs</code> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> <code>remove_image_on_exit</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/image.py</code> <pre><code>def __init__(\n    self,\n    dockerfile: Optional[Path] = None,\n    context: Optional[Path] = None,\n    target: Optional[str] = None,\n    docker_client_kwargs: Optional[Dict] = None,\n    *,\n    remove_image_on_exit: bool = True,\n) -&gt; None:\n    self.dockerfile = str(dockerfile) if dockerfile else None\n    self.context = str(context) if context else \".\"\n    self.target = target\n    self._docker_client = DockerClient(**(docker_client_kwargs or {}))\n    self._remove_image_on_exit = remove_image_on_exit\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.EphemeralDockerImage.image","title":"image  <code>instance-attribute</code>","text":"<pre><code>image\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.EphemeralDockerImage.dockerfile","title":"dockerfile  <code>instance-attribute</code>","text":"<pre><code>dockerfile = str(dockerfile) if dockerfile else None\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.EphemeralDockerImage.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context = str(context) if context else '.'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.EphemeralDockerImage.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = target\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer","title":"WebContainer","text":"<pre><code>WebContainer(image, internal_port, edge_port=None, http_healthcheck_path=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code>, <code>ABC</code></p> <p>Abstract class for web application containers.</p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>http_healthcheck_path</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def __init__(\n    self,\n    image: str,\n    internal_port: int,\n    edge_port: Optional[int] = None,\n    http_healthcheck_path: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(image, disable_logging=disable_logging, **kwargs)\n    self.internal_port = internal_port\n    self.edge_port = edge_port or get_available_port()\n    self.http_healthcheck_path = http_healthcheck_path\n    self.with_bind_ports(internal_port, self.edge_port)\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer.internal_port","title":"internal_port  <code>instance-attribute</code>","text":"<pre><code>internal_port = internal_port\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer.edge_port","title":"edge_port  <code>instance-attribute</code>","text":"<pre><code>edge_port = edge_port or get_available_port()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer.http_healthcheck_path","title":"http_healthcheck_path  <code>instance-attribute</code>","text":"<pre><code>http_healthcheck_path = http_healthcheck_path\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer.get_internal_url","title":"get_internal_url","text":"<pre><code>get_internal_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def get_internal_url(self) -&gt; str:\n    ip = self.get_container_internal_ip()\n    return f\"http://{ip}:{self.internal_port}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer.get_external_url","title":"get_external_url","text":"<pre><code>get_external_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def get_external_url(self) -&gt; str:\n    host = self.get_container_host_ip()\n    return f\"http://{host}:{self.edge_port}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WebContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/web.py</code> <pre><code>def start(self) -&gt; \"WebContainer\":\n    super().start()\n    if self.http_healthcheck_path:\n        url = urllib.parse.urljoin(self.get_external_url(), self.http_healthcheck_path)\n        wait_for_http_healthcheck(url=url)\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DynamoDBAdminContainer","title":"DynamoDBAdminContainer","text":"<pre><code>DynamoDBAdminContainer(dynamo_endpoint, image='aaronshaf/dynamodb-admin:latest', internal_port=8001, edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>DynamoDB Admin container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> </ul> PARAMETER DESCRIPTION <code>dynamo_endpoint</code> <p> TYPE: <code>str</code> </p> <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'aaronshaf/dynamodb-admin:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>8001</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/dynamodb_admin.py</code> <pre><code>def __init__(\n    self,\n    dynamo_endpoint: str,\n    image: str = \"aaronshaf/dynamodb-admin:latest\",\n    internal_port: int = 8001,\n    edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image=image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=\"/\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\") or \"testing\"  # nosec: B105\n    self.aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\") or \"testing\"  # nosec: B105\n\n    self.with_env(\"AWS_REGION\", self.region_name)\n    self.with_env(\"AWS_DEFAULT_REGION\", self.region_name)\n    self.with_env(\"AWS_ACCESS_KEY_ID\", self.aws_access_key_id)\n    self.with_env(\"AWS_SECRET_ACCESS_KEY\", self.aws_secret_access_key)\n\n    self.with_env(\"DYNAMO_ENDPOINT\", dynamo_endpoint)\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DynamoDBAdminContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DynamoDBAdminContainer.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id = getenv('AWS_ACCESS_KEY_ID') or 'testing'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DynamoDBAdminContainer.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key = getenv('AWS_SECRET_ACCESS_KEY') or 'testing'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DynamoDBAdminContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/dynamodb_admin.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"DynamoDB Admin: http://localhost:{self.edge_port}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer","title":"LocalStackContainer","text":"<pre><code>LocalStackContainer(image='localstack/localstack:3', internal_port=4566, edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>LocalStack container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>AWS_ACCESS_KEY_ID</code> - defaults to <code>testing</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code> - defaults to <code>testing</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'localstack/localstack:3'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>4566</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"localstack/localstack:3\",\n    internal_port: int = 4566,\n    edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=\"/_localstack/health\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\") or \"testing\"  # nosec: B105\n    self.aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\") or \"testing\"  # nosec: B105\n\n    self.with_env(\"AWS_REGION\", self.region_name)\n    self.with_env(\"AWS_DEFAULT_REGION\", self.region_name)\n    self.with_env(\"AWS_ACCESS_KEY_ID\", self.aws_access_key_id)\n    self.with_env(\"AWS_SECRET_ACCESS_KEY\", self.aws_secret_access_key)\n\n    # Docker is needed for running AWS Lambda container\n    self.with_env(\"LAMBDA_DOCKER_NETWORK\", self.network)\n    self.with_volume_mapping(\"/var/run/docker.sock\", \"/var/run/docker.sock\")\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id = getenv('AWS_ACCESS_KEY_ID') or 'testing'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key = getenv('AWS_SECRET_ACCESS_KEY') or 'testing'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"LocalStack started: http://localhost:{self.edge_port}/\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer.get_aws_client_config","title":"get_aws_client_config","text":"<pre><code>get_aws_client_config()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def get_aws_client_config(self) -&gt; AWSClientConfig:\n    return AWSClientConfig(\n        region_name=self.region_name,\n        aws_access_key_id=self.aws_access_key_id,\n        aws_secret_access_key=self.aws_secret_access_key,\n        endpoint_url=self.get_external_url(),\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.LocalStackContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/localstack.py</code> <pre><code>def start(self) -&gt; \"LocalStackContainer\":\n    super().start()\n    wait_for_logs(self, r\"Ready\\.\\n\", timeout=10.0)\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer","title":"MinioContainer","text":"<pre><code>MinioContainer(image='minio/minio:latest', s3_api_internal_port=9000, s3_api_edge_port=None, console_internal_port=9001, console_edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>Minio container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>MINIO_ROOT_USER</code> - defaults to <code>minioadmin</code></li> <li><code>MINIO_ROOT_PASSWORD</code> - defaults to <code>minioadmin</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'minio/minio:latest'</code> </p> <code>s3_api_internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>9000</code> </p> <code>s3_api_edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>console_internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>9001</code> </p> <code>console_edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"minio/minio:latest\",\n    s3_api_internal_port: int = 9000,\n    s3_api_edge_port: Optional[int] = None,\n    console_internal_port: int = 9001,\n    console_edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=s3_api_internal_port,\n        edge_port=s3_api_edge_port,\n        http_healthcheck_path=\"/minio/health/live\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n    self.s3_api_internal_port = s3_api_internal_port\n    self.s3_api_edge_port = self.edge_port\n    self.console_internal_port = console_internal_port\n    self.console_edge_port = console_edge_port or get_available_port()\n\n    self.with_bind_ports(console_internal_port, self.console_edge_port)\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.minio_root_user = os.getenv(\"MINIO_ROOT_USER\") or \"minioadmin\"  # nosec: B105\n    self.minio_root_password = os.getenv(\"MINIO_ROOT_PASSWORD\") or \"minioadmin\"  # nosec: B105\n\n    self.with_env(\"MINIO_ROOT_USER\", self.minio_root_user)\n    self.with_env(\"MINIO_ROOT_PASSWORD\", self.minio_root_password)\n\n    self.with_command(\n        f'server /data --address \":{self.s3_api_internal_port}\" --console-address \":{self.console_internal_port}\"'\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.s3_api_internal_port","title":"s3_api_internal_port  <code>instance-attribute</code>","text":"<pre><code>s3_api_internal_port = s3_api_internal_port\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.s3_api_edge_port","title":"s3_api_edge_port  <code>instance-attribute</code>","text":"<pre><code>s3_api_edge_port = edge_port\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.console_internal_port","title":"console_internal_port  <code>instance-attribute</code>","text":"<pre><code>console_internal_port = console_internal_port\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.console_edge_port","title":"console_edge_port  <code>instance-attribute</code>","text":"<pre><code>console_edge_port = console_edge_port or get_available_port()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.minio_root_user","title":"minio_root_user  <code>instance-attribute</code>","text":"<pre><code>minio_root_user = getenv('MINIO_ROOT_USER') or 'minioadmin'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.minio_root_password","title":"minio_root_password  <code>instance-attribute</code>","text":"<pre><code>minio_root_password = getenv('MINIO_ROOT_PASSWORD') or 'minioadmin'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return (\n        \"Minio started: \"\n        f\"S3-API: http://localhost:{self.s3_api_edge_port}/; \"  # noqa: E702\n        f\"console: http://localhost:{self.console_edge_port}/\"\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.get_aws_client_config","title":"get_aws_client_config","text":"<pre><code>get_aws_client_config()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def get_aws_client_config(self) -&gt; AWSClientConfig:\n    return AWSClientConfig(\n        region_name=self.region_name,\n        aws_access_key_id=self.minio_root_user,\n        aws_secret_access_key=self.minio_root_password,\n        endpoint_url=self.get_external_url(),\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MinioContainer.reset_minio","title":"reset_minio","text":"<pre><code>reset_minio()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/minio.py</code> <pre><code>def reset_minio(self) -&gt; None:\n    self.exec([\"mc\", \"rm\", \"--recursive\", \"--dangerous\", \"--force\", \"data/\"])\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer","title":"MotoContainer","text":"<pre><code>MotoContainer(image='motoserver/moto:latest', internal_port=5000, edge_port=None, region_name=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>Moto container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>AWS_REGION</code> or <code>AWS_DEFAULT_REGION</code> - defaults to <code>us-east-1</code></li> <li><code>AWS_ACCESS_KEY_ID</code> - defaults to <code>testing</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code> - defaults to <code>testing</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'motoserver/moto:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>5000</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>region_name</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"motoserver/moto:latest\",\n    internal_port: int = 5000,\n    edge_port: Optional[int] = None,\n    region_name: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=\"/moto-api/data.json\",\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.region_name = region_name or os.getenv(\"AWS_REGION\") or os.getenv(\"AWS_DEFAULT_REGION\") or \"us-east-1\"\n    self.aws_access_key_id = os.getenv(\"AWS_ACCESS_KEY_ID\") or \"testing\"  # nosec: B105\n    self.aws_secret_access_key = os.getenv(\"AWS_SECRET_ACCESS_KEY\") or \"testing\"  # nosec: B105\n\n    self.with_env(\"AWS_REGION\", self.region_name)\n    self.with_env(\"AWS_DEFAULT_REGION\", self.region_name)\n    self.with_env(\"AWS_ACCESS_KEY_ID\", self.aws_access_key_id)\n    self.with_env(\"AWS_SECRET_ACCESS_KEY\", self.aws_secret_access_key)\n\n    self.with_env(\"MOTO_PORT\", str(self.internal_port))\n\n    # Docker is needed for running AWS Lambda container\n    self.with_env(\"MOTO_DOCKER_NETWORK_NAME\", self.network)\n    self.with_volume_mapping(\"/var/run/docker.sock\", \"/var/run/docker.sock\")\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name = region_name or getenv('AWS_REGION') or getenv('AWS_DEFAULT_REGION') or 'us-east-1'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id = getenv('AWS_ACCESS_KEY_ID') or 'testing'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key = getenv('AWS_SECRET_ACCESS_KEY') or 'testing'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"Moto dashboard: http://localhost:{self.edge_port}/moto-api\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.get_aws_client_config","title":"get_aws_client_config","text":"<pre><code>get_aws_client_config()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def get_aws_client_config(self) -&gt; AWSClientConfig:\n    return AWSClientConfig(\n        region_name=self.region_name,\n        aws_access_key_id=self.aws_access_key_id,\n        aws_secret_access_key=self.aws_secret_access_key,\n        endpoint_url=self.get_external_url(),\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def start(self) -&gt; \"MotoContainer\":\n    super().start()\n    wait_for_logs(self, \"Running on all addresses\", timeout=10.0)\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MotoContainer.reset_moto","title":"reset_moto","text":"<pre><code>reset_moto()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/moto.py</code> <pre><code>def reset_moto(self) -&gt; None:\n    self.exec([\"curl\", \"-X\", \"POST\", f\"http://localhost:{self.internal_port}/moto-api/reset\"])\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.TomodachiContainer","title":"TomodachiContainer","text":"<pre><code>TomodachiContainer(image, internal_port=9700, edge_port=None, http_healthcheck_path=None, *, export_coverage=False, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> <p>Tomodachi container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE</code> - defaults to <code>False</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>9700</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>http_healthcheck_path</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>export_coverage</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def __init__(\n    self,\n    image: str,\n    internal_port: int = 9700,\n    edge_port: Optional[int] = None,\n    http_healthcheck_path: Optional[str] = None,\n    *,\n    export_coverage: bool = False,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image=image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        http_healthcheck_path=http_healthcheck_path,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n    self._export_coverage = export_coverage or bool(os.getenv(\"TOMODACHI_TESTCONTAINER_EXPORT_COVERAGE\"))\n    if self._export_coverage:\n        self._configure_coverage_export()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.TomodachiContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"Tomodachi service: http://localhost:{self.edge_port}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.TomodachiContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def start(self) -&gt; \"TomodachiContainer\":\n    super().start()\n    # Apart from HTTP healthcheck, we need to wait for \"started service\" log\n    # to make sure messaging transport like AWS SNS SQS is also up and running.\n    # It's started independently from HTTP transport.\n\n    # Different service start messages depending on tomodachi version\n    # tomodachi &lt; 0.26.0 - \"Started service\"\n    # tomodachi &gt;= 0.26.0 - \"started service successfully\"\n    # using (?i) to ignore case to support both versions\n    wait_for_logs(self, \"(?i)started service\", timeout=10.0)\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.TomodachiContainer.stop","title":"stop","text":"<pre><code>stop()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/tomodachi.py</code> <pre><code>def stop(self) -&gt; None:\n    if self._export_coverage:\n        with suppress(Exception):\n            self._stop_container_and_copy_coverage_report()\n    super().stop()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer","title":"WireMockContainer","text":"<pre><code>WireMockContainer(image='wiremock/wiremock:latest', internal_port=8080, edge_port=None, mapping_stubs=None, mapping_files=None, *, verbose=False, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>WebContainer</code></p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'wiremock/wiremock:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>8080</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>mapping_stubs</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>mapping_files</code> <p> TYPE: <code>Optional[Path]</code> DEFAULT: <code>None</code> </p> <code>verbose</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"wiremock/wiremock:latest\",\n    internal_port: int = 8080,\n    edge_port: Optional[int] = None,\n    mapping_stubs: Optional[Path] = None,\n    mapping_files: Optional[Path] = None,\n    *,\n    verbose: bool = False,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    mapping_stubs_env = os.getenv(\"WIREMOCK_TESTCONTAINER_MAPPING_STUBS\")\n    mapping_files_env = os.getenv(\"WIREMOCK_TESTCONTAINER_MAPPING_FILES\")\n\n    self.mapping_stubs = mapping_stubs or (Path(mapping_stubs_env) if mapping_stubs_env else None)\n    self.mapping_files = mapping_files or (Path(mapping_files_env) if mapping_files_env else None)\n\n    if verbose or os.getenv(\"WIREMOCK_TESTCONTAINER_VERBOSE\"):\n        self.with_command(\"--verbose\")\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.MAPPING_STUBS_DIR","title":"MAPPING_STUBS_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAPPING_STUBS_DIR = Path('/home/wiremock/mappings/')\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.MAPPING_FILES_DIR","title":"MAPPING_FILES_DIR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MAPPING_FILES_DIR = Path('/home/wiremock/__files/')\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.mapping_stubs","title":"mapping_stubs  <code>instance-attribute</code>","text":"<pre><code>mapping_stubs = mapping_stubs or Path(mapping_stubs_env) if mapping_stubs_env else None\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.mapping_files","title":"mapping_files  <code>instance-attribute</code>","text":"<pre><code>mapping_files = mapping_files or Path(mapping_files_env) if mapping_files_env else None\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"Wiremock admin: http://localhost:{self.edge_port}/__admin\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.start","title":"start","text":"<pre><code>start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def start(self) -&gt; \"WireMockContainer\":\n    super().start()\n    wait_for_logs(self, \"port:\", timeout=10.0)\n    self.load_mappings_from_files()\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.load_mappings_from_files","title":"load_mappings_from_files","text":"<pre><code>load_mappings_from_files()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def load_mappings_from_files(self) -&gt; None:\n    self._copy_mapping_stubs_to_container()\n    self._copy_mapping_files_to_container()\n    self.reset_mappings()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.delete_mappings","title":"delete_mappings","text":"<pre><code>delete_mappings()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def delete_mappings(self) -&gt; None:\n    self.exec([\"curl\", \"-X\", \"DELETE\", f\"http://localhost:{self.internal_port}/__admin/mappings\"])\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.WireMockContainer.reset_mappings","title":"reset_mappings","text":"<pre><code>reset_mappings()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/wiremock.py</code> <pre><code>def reset_mappings(self) -&gt; None:\n    self.exec([\"curl\", \"-X\", \"POST\", f\"http://localhost:{self.internal_port}/__admin/mappings/reset\"])\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer","title":"DatabaseContainer","text":"<pre><code>DatabaseContainer(image, internal_port, edge_port=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code>, <code>ABC</code></p> <p>Abstract class for relational database containers.</p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def __init__(\n    self,\n    image: str,\n    internal_port: int,\n    edge_port: Optional[int] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(image, disable_logging=disable_logging, **kwargs)\n    self.internal_port = internal_port\n    self.edge_port = edge_port or get_available_port()\n    self.with_bind_ports(internal_port, self.edge_port)\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.internal_port","title":"internal_port  <code>instance-attribute</code>","text":"<pre><code>internal_port = internal_port\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.edge_port","title":"edge_port  <code>instance-attribute</code>","text":"<pre><code>edge_port = edge_port or get_available_port()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.drivername","title":"drivername  <code>instance-attribute</code>","text":"<pre><code>drivername\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.database","title":"database  <code>instance-attribute</code>","text":"<pre><code>database\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.get_internal_url","title":"get_internal_url","text":"<pre><code>get_internal_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def get_internal_url(self) -&gt; DatabaseURL:\n    return DatabaseURL(\n        drivername=self.drivername,\n        username=self.username,\n        password=self.password,\n        host=self.get_container_internal_ip(),\n        port=self.internal_port,\n        database=self.database,\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.get_external_url","title":"get_external_url","text":"<pre><code>get_external_url()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def get_external_url(self) -&gt; DatabaseURL:\n    return DatabaseURL(\n        drivername=self.drivername,\n        username=self.username,\n        password=self.password,\n        host=self.get_container_host_ip(),\n        port=self.edge_port,\n        database=self.database,\n    )\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.DatabaseContainer.start","title":"start","text":"<pre><code>start(timeout=20.0)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>20.0</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/common/database.py</code> <pre><code>def start(self, timeout: float = 20.0) -&gt; \"DatabaseContainer\":\n    super().start()\n    wait_for_database_healthcheck(url=self.get_external_url(), timeout=timeout)\n    return self\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer","title":"MySQLContainer","text":"<pre><code>MySQLContainer(image='mysql:8', internal_port=3306, edge_port=None, drivername=None, username=None, root_password=None, password=None, database=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DatabaseContainer</code></p> <p>MySQL container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>MYSQL_DRIVERNAME</code> - defaults to <code>mysql+pymysql</code></li> <li><code>MYSQL_USER</code> - defaults to <code>username</code></li> <li><code>MYSQL_ROOT_PASSWORD</code> - defaults to <code>root</code></li> <li><code>MYSQL_PASSWORD</code> - defaults to <code>password</code></li> <li><code>MYSQL_DATABASE</code> - defaults to <code>db</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'mysql:8'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>3306</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>drivername</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>username</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>root_password</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>password</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>database</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/mysql.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"mysql:8\",\n    internal_port: int = 3306,\n    edge_port: Optional[int] = None,\n    drivername: Optional[str] = None,\n    username: Optional[str] = None,\n    root_password: Optional[str] = None,\n    password: Optional[str] = None,\n    database: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.drivername = drivername or os.getenv(\"MYSQL_DRIVERNAME\") or \"mysql+pymysql\"\n    self.username = username or os.getenv(\"MYSQL_USER\") or \"username\"\n    self.root_password = root_password or os.getenv(\"MYSQL_ROOT_PASSWORD\") or \"root\"\n    self.password = password or os.getenv(\"MYSQL_PASSWORD\") or \"password\"\n    self.database = database or os.getenv(\"MYSQL_DATABASE\") or \"db\"\n\n    if self.username == \"root\":\n        self.root_password = self.password\n\n    self.with_env(\"MYSQL_USER\", self.username)\n    self.with_env(\"MYSQL_ROOT_PASSWORD\", self.root_password)\n    self.with_env(\"MYSQL_PASSWORD\", self.password)\n    self.with_env(\"MYSQL_DATABASE\", self.database)\n\n    # Do not flush data on disk to improve test container performance\n    # https://pythonspeed.com/articles/faster-db-tests/\n    self.with_command(\"--innodb_flush_method=O_DIRECT_NO_FSYNC\")\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer.drivername","title":"drivername  <code>instance-attribute</code>","text":"<pre><code>drivername = drivername or getenv('MYSQL_DRIVERNAME') or 'mysql+pymysql'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username or getenv('MYSQL_USER') or 'username'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer.root_password","title":"root_password  <code>instance-attribute</code>","text":"<pre><code>root_password = root_password or getenv('MYSQL_ROOT_PASSWORD') or 'root'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password or getenv('MYSQL_PASSWORD') or 'password'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer.database","title":"database  <code>instance-attribute</code>","text":"<pre><code>database = database or getenv('MYSQL_DATABASE') or 'db'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.MySQLContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/mysql.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"MySQL started: {self.get_external_url()}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.PostgreSQLContainer","title":"PostgreSQLContainer","text":"<pre><code>PostgreSQLContainer(image='postgres:16', internal_port=5432, edge_port=None, drivername=None, username=None, password=None, database=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DatabaseContainer</code></p> <p>PostgreSQL container.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>POSTGRES_DRIVERNAME</code> - defaults to <code>postgresql+psycopg</code></li> <li><code>POSTGRES_USER</code> - defaults to <code>username</code></li> <li><code>POSTGRES_PASSWORD</code> - defaults to <code>password</code></li> <li><code>POSTGRES_DB</code> - defaults to <code>db</code></li> </ul> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'postgres:16'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>5432</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>drivername</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>username</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>password</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>database</code> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/postgres.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"postgres:16\",\n    internal_port: int = 5432,\n    edge_port: Optional[int] = None,\n    drivername: Optional[str] = None,\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    database: Optional[str] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(\n        image,\n        internal_port=internal_port,\n        edge_port=edge_port,\n        disable_logging=disable_logging,\n        **kwargs,\n    )\n\n    self.drivername = drivername or os.getenv(\"POSTGRES_DRIVERNAME\") or \"postgresql+psycopg\"\n    self.username = username or os.getenv(\"POSTGRES_USER\") or \"username\"\n    self.password = password or os.getenv(\"POSTGRES_PASSWORD\") or \"password\"\n    self.database = database or os.getenv(\"POSTGRES_DB\") or \"db\"\n\n    self.with_env(\"POSTGRES_USER\", self.username)\n    self.with_env(\"POSTGRES_PASSWORD\", self.password)\n    self.with_env(\"POSTGRES_DB\", self.database)\n\n    # Do not flush data on disk to improve test container performance\n    # https://pythonspeed.com/articles/faster-db-tests/\n    self.with_command(\"-c fsync=off\")\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.PostgreSQLContainer.drivername","title":"drivername  <code>instance-attribute</code>","text":"<pre><code>drivername = drivername or getenv('POSTGRES_DRIVERNAME') or 'postgresql+psycopg'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.PostgreSQLContainer.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username = username or getenv('POSTGRES_USER') or 'username'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.PostgreSQLContainer.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password = password or getenv('POSTGRES_PASSWORD') or 'password'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.PostgreSQLContainer.database","title":"database  <code>instance-attribute</code>","text":"<pre><code>database = database or getenv('POSTGRES_DB') or 'db'\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.PostgreSQLContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/postgres.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"PostgreSQL started: {self.get_external_url()}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer","title":"SFTPContainer","text":"<pre><code>SFTPContainer(image='atmoz/sftp:latest', internal_port=22, edge_port=None, disable_logging=False, **kwargs)\n</code></pre> <p>               Bases: <code>DockerContainer</code></p> PARAMETER DESCRIPTION <code>image</code> <p> TYPE: <code>str</code> DEFAULT: <code>'atmoz/sftp:latest'</code> </p> <code>internal_port</code> <p> TYPE: <code>int</code> DEFAULT: <code>22</code> </p> <code>edge_port</code> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>None</code> </p> <code>disable_logging</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def __init__(\n    self,\n    image: str = \"atmoz/sftp:latest\",\n    internal_port: int = 22,\n    edge_port: Optional[int] = None,\n    disable_logging: bool = False,\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(image, disable_logging=disable_logging, **kwargs)\n    self.internal_port = internal_port\n    self.edge_port = edge_port or get_available_port()\n    self.with_bind_ports(self.internal_port, self.edge_port)\n\n    self.with_command(\"userpass:pass:1001 userssh::1002\")\n\n    self.authorized_private_key = asyncssh.generate_private_key(\"ssh-ed25519\")\n    self.authorized_public_key = self.authorized_private_key.export_public_key().decode()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.internal_port","title":"internal_port  <code>instance-attribute</code>","text":"<pre><code>internal_port = internal_port\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.edge_port","title":"edge_port  <code>instance-attribute</code>","text":"<pre><code>edge_port = edge_port or get_available_port()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.authorized_private_key","title":"authorized_private_key  <code>instance-attribute</code>","text":"<pre><code>authorized_private_key = generate_private_key('ssh-ed25519')\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.authorized_public_key","title":"authorized_public_key  <code>instance-attribute</code>","text":"<pre><code>authorized_public_key = decode()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.log_message_on_container_start","title":"log_message_on_container_start","text":"<pre><code>log_message_on_container_start()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def log_message_on_container_start(self) -&gt; str:\n    return f\"SFTP server running on port: {self.edge_port}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.get_internal_conn_details","title":"get_internal_conn_details","text":"<pre><code>get_internal_conn_details()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_internal_conn_details(self) -&gt; ConnectionDetails:\n    host = self.get_container_internal_ip()\n    return ConnectionDetails(host=host, port=self.internal_port)\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.get_external_conn_details","title":"get_external_conn_details","text":"<pre><code>get_external_conn_details()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_external_conn_details(self) -&gt; ConnectionDetails:\n    host = self.get_container_host_ip()\n    return ConnectionDetails(host=host, port=self.edge_port)\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.get_host_public_key","title":"get_host_public_key","text":"<pre><code>get_host_public_key()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_host_public_key(self) -&gt; str:\n    _, output = self.exec(\"bash -c 'cat /etc/ssh/ssh_host_ed25519_key.pub'\")\n    return bytes(output).decode().strip()\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.get_internal_known_host","title":"get_internal_known_host","text":"<pre><code>get_internal_known_host()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_internal_known_host(self) -&gt; str:\n    internal = self.get_internal_conn_details()\n    public_key = self.get_host_public_key()\n    return f\"{internal.host} {public_key}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.get_external_known_host","title":"get_external_known_host","text":"<pre><code>get_external_known_host()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_external_known_host(self) -&gt; str:\n    external = self.get_external_conn_details()\n    public_key = self.get_host_public_key()\n    return f\"{external.host} {public_key}\"\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.get_known_hosts","title":"get_known_hosts","text":"<pre><code>get_known_hosts()\n</code></pre> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def get_known_hosts(self) -&gt; asyncssh.SSHKnownHosts:\n    known_hosts = asyncssh.SSHKnownHosts()\n    for known_host in (self.get_internal_known_host(), self.get_external_known_host()):\n        known_hosts.load(known_host)\n    return known_hosts\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.add_authorized_key","title":"add_authorized_key","text":"<pre><code>add_authorized_key(username, uid, gid, public_key)\n</code></pre> PARAMETER DESCRIPTION <code>username</code> <p> TYPE: <code>str</code> </p> <code>uid</code> <p> TYPE: <code>str</code> </p> <code>gid</code> <p> TYPE: <code>str</code> </p> <code>public_key</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def add_authorized_key(self, username: str, uid: str, gid: str, public_key: str) -&gt; None:\n    self.exec(f\"bash -c 'mkdir -p /home/{username}/.ssh'\")\n    self.exec(f\"bash -c 'chmod 700 /home/{username}/.ssh'\")\n    self.exec(f\"bash -c 'touch /home/{username}/.ssh/authorized_keys'\")\n    self.exec(f\"bash -c 'chmod 600 /home/{username}/.ssh/authorized_keys'\")\n    self.exec(f\"bash -c 'echo \\\"{public_key}\\\" &gt;&gt; /home/{username}/.ssh/authorized_keys'\")\n    self.exec(f\"bash -c 'chown -R {uid}:{gid} /home/{username}/.ssh'\")\n</code></pre>"},{"location":"reference/containers/#tomodachi_testcontainers.SFTPContainer.start","title":"start","text":"<pre><code>start(timeout=10.0)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>10.0</code> </p> Source code in <code>src/tomodachi_testcontainers/containers/sftp.py</code> <pre><code>def start(self, timeout: float = 10.0) -&gt; \"SFTPContainer\":\n    super().start()\n    wait_for_logs(self, r\"Server listening on\", timeout=timeout)\n\n    self.exec(\"bash -c 'mkdir /home/userpass/upload &amp;&amp; chown -R 1001:1001 /home/userpass/upload'\")\n    self.exec(\"bash -c 'mkdir /home/userpass/download &amp;&amp; chown -R 1001:1001 /home/userpass/download'\")\n    self.exec(\"bash -c 'mkdir /home/userssh/upload &amp;&amp; chown -R 1002:1002 /home/userssh/upload'\")\n    self.exec(\"bash -c 'mkdir /home/userssh/download &amp;&amp; chown -R 1002:1002 /home/userssh/download'\")\n\n    self.add_authorized_key(username=\"userssh\", uid=\"1002\", gid=\"1002\", public_key=self.authorized_public_key)\n\n    return self\n</code></pre>"},{"location":"reference/fixtures/","title":"Fixtures","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures","title":"tomodachi_testcontainers.fixtures","text":"<p>Pytest fixtures.</p>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.testcontainer_image","title":"testcontainer_image","text":"<pre><code>testcontainer_image()\n</code></pre> <p>Builds a Docker image from a Dockerfile located in the current working directory and returns an image ID.</p> <p>The Docker image is removed on test session end.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>TESTCONTAINER_IMAGE_ID</code> - use given Image ID for creating a container.</li> <li><code>TESTCONTAINER_DOCKERFILE_PATH</code> - override path to the Dockerfile for building Docker image.</li> <li><code>TESTCONTAINER_DOCKER_BUILD_CONTEXT</code> - override Docker build context.</li> <li><code>TESTCONTAINER_DOCKER_BUILD_TARGET</code> - override Docker build target.</li> </ul> YIELDS DESCRIPTION <code>str</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/containers.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef testcontainer_image() -&gt; Generator[str, None, None]:\n    \"\"\"Builds a Docker image from a Dockerfile located in the current working directory and returns an image ID.\n\n    The Docker image is removed on test session end.\n\n    Configuration environment variables (set on host machine):\n\n    - `TESTCONTAINER_IMAGE_ID` - use given Image ID for creating a container.\n    - `TESTCONTAINER_DOCKERFILE_PATH` - override path to the Dockerfile for building Docker image.\n    - `TESTCONTAINER_DOCKER_BUILD_CONTEXT` - override Docker build context.\n    - `TESTCONTAINER_DOCKER_BUILD_TARGET` - override Docker build target.\n    \"\"\"\n    if image_id := os.getenv(\"TESTCONTAINER_IMAGE_ID\"):\n        yield image_id\n    else:\n        with EphemeralDockerImage(\n            dockerfile=(Path(v) if (v := os.getenv(\"TESTCONTAINER_DOCKERFILE_PATH\")) else None),\n            context=(Path(v) if (v := os.getenv(\"TESTCONTAINER_DOCKER_BUILD_CONTEXT\")) else None),\n            target=os.getenv(\"TESTCONTAINER_DOCKER_BUILD_TARGET\"),\n            # Don't remove the image on teardown if it's used by other pytest-xdist workers in parallel.\n            # The image will be eventually removed by the 'master' worker that exits last.\n            remove_image_on_exit=not os.getenv(\"PYTEST_XDIST_WORKER\"),\n        ) as image:\n            yield str(image.id)\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_container","title":"localstack_container","text":"<pre><code>localstack_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef localstack_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"LOCALSTACK_TESTCONTAINER_IMAGE_ID\", \"localstack/localstack:3\")\n    disable_logging = bool(os.getenv(\"LOCALSTACK_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with LocalStackContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_dynamodb_client","title":"localstack_dynamodb_client  <code>async</code>","text":"<pre><code>localstack_dynamodb_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_dynamodb_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[DynamoDBClient, None]:\n    async with get_session().create_client(\"dynamodb\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_iam_client","title":"localstack_iam_client  <code>async</code>","text":"<pre><code>localstack_iam_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_iam_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[IAMClient, None]:\n    async with get_session().create_client(\"iam\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_lambda_client","title":"localstack_lambda_client  <code>async</code>","text":"<pre><code>localstack_lambda_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_lambda_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[LambdaClient, None]:\n    async with get_session().create_client(\"lambda\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_s3_client","title":"localstack_s3_client  <code>async</code>","text":"<pre><code>localstack_s3_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_s3_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[S3Client, None]:\n    async with get_session().create_client(\"s3\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_sns_client","title":"localstack_sns_client  <code>async</code>","text":"<pre><code>localstack_sns_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_sns_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[SNSClient, None]:\n    async with get_session().create_client(\"sns\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_snssqs_tc","title":"localstack_snssqs_tc","text":"<pre><code>localstack_snssqs_tc(localstack_sns_client, localstack_sqs_client)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_sns_client</code> <p> TYPE: <code>SNSClient</code> </p> <code>localstack_sqs_client</code> <p> TYPE: <code>SQSClient</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef localstack_snssqs_tc(localstack_sns_client: SNSClient, localstack_sqs_client: SQSClient) -&gt; SNSSQSTestClient:\n    return SNSSQSTestClient(localstack_sns_client, localstack_sqs_client)\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_sqs_client","title":"localstack_sqs_client  <code>async</code>","text":"<pre><code>localstack_sqs_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_sqs_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[SQSClient, None]:\n    async with get_session().create_client(\"sqs\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack_ssm_client","title":"localstack_ssm_client  <code>async</code>","text":"<pre><code>localstack_ssm_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_ssm_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[SSMClient, None]:\n    async with get_session().create_client(\"ssm\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.restart_localstack_container_on_teardown","title":"restart_localstack_container_on_teardown","text":"<pre><code>restart_localstack_container_on_teardown(localstack_container)\n</code></pre> <p>Restarts the LocalStack container after each test.</p> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> YIELDS DESCRIPTION <code>None</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest.fixture\ndef restart_localstack_container_on_teardown(  # noqa: PT004\n    localstack_container: LocalStackContainer,\n) -&gt; Generator[None, None, None]:\n    \"\"\"Restarts the LocalStack container after each test.\"\"\"\n    yield\n    localstack_container.restart()\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.minio_container","title":"minio_container","text":"<pre><code>minio_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/minio.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef minio_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"MINIO_TESTCONTAINER_IMAGE_ID\", \"minio/minio:latest\")\n    disable_logging = bool(os.getenv(\"MINIO_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with MinioContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.minio_s3_client","title":"minio_s3_client  <code>async</code>","text":"<pre><code>minio_s3_client(minio_container)\n</code></pre> PARAMETER DESCRIPTION <code>minio_container</code> <p> TYPE: <code>MinioContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/minio.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def minio_s3_client(minio_container: MinioContainer) -&gt; AsyncGenerator[S3Client, None]:\n    async with get_session().create_client(\"s3\", **minio_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_container","title":"moto_container","text":"<pre><code>moto_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef moto_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"MOTO_TESTCONTAINER_IMAGE_ID\", \"motoserver/moto:latest\")\n    disable_logging = bool(os.getenv(\"MOTO_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with MotoContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_dynamodb_client","title":"moto_dynamodb_client  <code>async</code>","text":"<pre><code>moto_dynamodb_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_dynamodb_client(moto_container: MotoContainer) -&gt; AsyncGenerator[DynamoDBClient, None]:\n    async with get_session().create_client(\"dynamodb\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_iam_client","title":"moto_iam_client  <code>async</code>","text":"<pre><code>moto_iam_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_iam_client(moto_container: MotoContainer) -&gt; AsyncGenerator[IAMClient, None]:\n    async with get_session().create_client(\"iam\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_lambda_client","title":"moto_lambda_client  <code>async</code>","text":"<pre><code>moto_lambda_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_lambda_client(moto_container: MotoContainer) -&gt; AsyncGenerator[LambdaClient, None]:\n    async with get_session().create_client(\"lambda\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_s3_client","title":"moto_s3_client  <code>async</code>","text":"<pre><code>moto_s3_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_s3_client(moto_container: MotoContainer) -&gt; AsyncGenerator[S3Client, None]:\n    async with get_session().create_client(\"s3\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_sns_client","title":"moto_sns_client  <code>async</code>","text":"<pre><code>moto_sns_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_sns_client(moto_container: MotoContainer) -&gt; AsyncGenerator[SNSClient, None]:\n    async with get_session().create_client(\"sns\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_snssqs_tc","title":"moto_snssqs_tc","text":"<pre><code>moto_snssqs_tc(moto_sns_client, moto_sqs_client)\n</code></pre> PARAMETER DESCRIPTION <code>moto_sns_client</code> <p> TYPE: <code>SNSClient</code> </p> <code>moto_sqs_client</code> <p> TYPE: <code>SQSClient</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef moto_snssqs_tc(moto_sns_client: SNSClient, moto_sqs_client: SQSClient) -&gt; SNSSQSTestClient:\n    return SNSSQSTestClient(moto_sns_client, moto_sqs_client)\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_sqs_client","title":"moto_sqs_client  <code>async</code>","text":"<pre><code>moto_sqs_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_sqs_client(moto_container: MotoContainer) -&gt; AsyncGenerator[SQSClient, None]:\n    async with get_session().create_client(\"sqs\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto_ssm_client","title":"moto_ssm_client  <code>async</code>","text":"<pre><code>moto_ssm_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_ssm_client(moto_container: MotoContainer) -&gt; AsyncGenerator[SSMClient, None]:\n    async with get_session().create_client(\"ssm\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.reset_moto_container_on_teardown","title":"reset_moto_container_on_teardown","text":"<pre><code>reset_moto_container_on_teardown(moto_container)\n</code></pre> <p>Removes all mocked resources from Moto after each test without restarting the container.</p> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> YIELDS DESCRIPTION <code>None</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest.fixture\ndef reset_moto_container_on_teardown(moto_container: MotoContainer) -&gt; Generator[None, None, None]:  # noqa: PT004\n    \"\"\"Removes all mocked resources from Moto after each test without restarting the container.\"\"\"\n    yield\n    moto_container.reset_moto()\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.reset_wiremock_container_on_teardown","title":"reset_wiremock_container_on_teardown","text":"<pre><code>reset_wiremock_container_on_teardown(wiremock_container)\n</code></pre> <p>Deletes all stub mappings from WireMock after each test.</p> PARAMETER DESCRIPTION <code>wiremock_container</code> <p> TYPE: <code>WireMockContainer</code> </p> YIELDS DESCRIPTION <code>None</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/wiremock.py</code> <pre><code>@pytest.fixture\ndef reset_wiremock_container_on_teardown(  # noqa: PT004\n    wiremock_container: WireMockContainer,\n) -&gt; Generator[None, None, None]:\n    \"\"\"Deletes all stub mappings from WireMock after each test.\"\"\"\n    yield\n    wiremock_container.delete_mappings()\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.wiremock_container","title":"wiremock_container","text":"<pre><code>wiremock_container()\n</code></pre> YIELDS DESCRIPTION <code>WireMockContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/wiremock.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef wiremock_container() -&gt; Generator[WireMockContainer, None, None]:\n    image = os.getenv(\"WIREMOCK_TESTCONTAINER_IMAGE_ID\", \"wiremock/wiremock:latest\")\n    disable_logging = bool(os.getenv(\"WIREMOCK_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with WireMockContainer(image, disable_logging=disable_logging) as container:\n        container = cast(WireMockContainer, container)\n        if WireMockConfig is not None:\n            WireMockConfig.base_url = f\"{container.get_external_url()}/__admin/\"\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.mysql_container","title":"mysql_container","text":"<pre><code>mysql_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/mysql.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef mysql_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"MYSQL_TESTCONTAINER_IMAGE_ID\", \"mysql:8\")\n    disable_logging = bool(os.getenv(\"MYSQL_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with MySQLContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.postgres_container","title":"postgres_container","text":"<pre><code>postgres_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/postgres.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef postgres_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"POSTGRES_TESTCONTAINER_IMAGE_ID\", \"postgres:16\")\n    disable_logging = bool(os.getenv(\"POSTGRES_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with PostgreSQLContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.sftp_container","title":"sftp_container","text":"<pre><code>sftp_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/sftp.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef sftp_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"SFTP_TESTCONTAINER_IMAGE_ID\", \"atmoz/sftp:latest\")\n    disable_logging = bool(os.getenv(\"SFTP_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with SFTPContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.userpass_sftp_client","title":"userpass_sftp_client  <code>async</code>","text":"<pre><code>userpass_sftp_client(sftp_container)\n</code></pre> PARAMETER DESCRIPTION <code>sftp_container</code> <p> TYPE: <code>SFTPContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/sftp.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def userpass_sftp_client(sftp_container: SFTPContainer) -&gt; AsyncGenerator[asyncssh.SFTPClient, None]:\n    conn_details = sftp_container.get_external_conn_details()\n    async with asyncssh.connect(\n        host=conn_details.host,\n        port=conn_details.port,\n        username=\"userpass\",\n        password=\"pass\",  # nosec: B106\n        known_hosts=sftp_container.get_known_hosts(),\n    ) as ssh_conn:\n        async with ssh_conn.start_sftp_client() as sftp_client:\n            yield sftp_client\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.userssh_sftp_client","title":"userssh_sftp_client  <code>async</code>","text":"<pre><code>userssh_sftp_client(sftp_container)\n</code></pre> PARAMETER DESCRIPTION <code>sftp_container</code> <p> TYPE: <code>SFTPContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/sftp.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def userssh_sftp_client(sftp_container: SFTPContainer) -&gt; AsyncGenerator[asyncssh.SFTPClient, None]:\n    conn_details = sftp_container.get_external_conn_details()\n    async with asyncssh.connect(\n        host=conn_details.host,\n        port=conn_details.port,\n        username=\"userssh\",\n        client_keys=sftp_container.authorized_private_key,\n        known_hosts=sftp_container.get_known_hosts(),\n    ) as ssh_conn:\n        async with ssh_conn.start_sftp_client() as sftp_client:\n            yield sftp_client\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.containers","title":"tomodachi_testcontainers.fixtures.containers","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.containers.testcontainer_image","title":"testcontainer_image","text":"<pre><code>testcontainer_image()\n</code></pre> <p>Builds a Docker image from a Dockerfile located in the current working directory and returns an image ID.</p> <p>The Docker image is removed on test session end.</p> <p>Configuration environment variables (set on host machine):</p> <ul> <li><code>TESTCONTAINER_IMAGE_ID</code> - use given Image ID for creating a container.</li> <li><code>TESTCONTAINER_DOCKERFILE_PATH</code> - override path to the Dockerfile for building Docker image.</li> <li><code>TESTCONTAINER_DOCKER_BUILD_CONTEXT</code> - override Docker build context.</li> <li><code>TESTCONTAINER_DOCKER_BUILD_TARGET</code> - override Docker build target.</li> </ul> YIELDS DESCRIPTION <code>str</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/containers.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef testcontainer_image() -&gt; Generator[str, None, None]:\n    \"\"\"Builds a Docker image from a Dockerfile located in the current working directory and returns an image ID.\n\n    The Docker image is removed on test session end.\n\n    Configuration environment variables (set on host machine):\n\n    - `TESTCONTAINER_IMAGE_ID` - use given Image ID for creating a container.\n    - `TESTCONTAINER_DOCKERFILE_PATH` - override path to the Dockerfile for building Docker image.\n    - `TESTCONTAINER_DOCKER_BUILD_CONTEXT` - override Docker build context.\n    - `TESTCONTAINER_DOCKER_BUILD_TARGET` - override Docker build target.\n    \"\"\"\n    if image_id := os.getenv(\"TESTCONTAINER_IMAGE_ID\"):\n        yield image_id\n    else:\n        with EphemeralDockerImage(\n            dockerfile=(Path(v) if (v := os.getenv(\"TESTCONTAINER_DOCKERFILE_PATH\")) else None),\n            context=(Path(v) if (v := os.getenv(\"TESTCONTAINER_DOCKER_BUILD_CONTEXT\")) else None),\n            target=os.getenv(\"TESTCONTAINER_DOCKER_BUILD_TARGET\"),\n            # Don't remove the image on teardown if it's used by other pytest-xdist workers in parallel.\n            # The image will be eventually removed by the 'master' worker that exits last.\n            remove_image_on_exit=not os.getenv(\"PYTEST_XDIST_WORKER\"),\n        ) as image:\n            yield str(image.id)\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack","title":"tomodachi_testcontainers.fixtures.localstack","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_container","title":"localstack_container","text":"<pre><code>localstack_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef localstack_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"LOCALSTACK_TESTCONTAINER_IMAGE_ID\", \"localstack/localstack:3\")\n    disable_logging = bool(os.getenv(\"LOCALSTACK_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with LocalStackContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.restart_localstack_container_on_teardown","title":"restart_localstack_container_on_teardown","text":"<pre><code>restart_localstack_container_on_teardown(localstack_container)\n</code></pre> <p>Restarts the LocalStack container after each test.</p> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> YIELDS DESCRIPTION <code>None</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest.fixture\ndef restart_localstack_container_on_teardown(  # noqa: PT004\n    localstack_container: LocalStackContainer,\n) -&gt; Generator[None, None, None]:\n    \"\"\"Restarts the LocalStack container after each test.\"\"\"\n    yield\n    localstack_container.restart()\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_dynamodb_client","title":"localstack_dynamodb_client  <code>async</code>","text":"<pre><code>localstack_dynamodb_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_dynamodb_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[DynamoDBClient, None]:\n    async with get_session().create_client(\"dynamodb\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_iam_client","title":"localstack_iam_client  <code>async</code>","text":"<pre><code>localstack_iam_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_iam_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[IAMClient, None]:\n    async with get_session().create_client(\"iam\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_lambda_client","title":"localstack_lambda_client  <code>async</code>","text":"<pre><code>localstack_lambda_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_lambda_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[LambdaClient, None]:\n    async with get_session().create_client(\"lambda\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_s3_client","title":"localstack_s3_client  <code>async</code>","text":"<pre><code>localstack_s3_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_s3_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[S3Client, None]:\n    async with get_session().create_client(\"s3\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_sns_client","title":"localstack_sns_client  <code>async</code>","text":"<pre><code>localstack_sns_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_sns_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[SNSClient, None]:\n    async with get_session().create_client(\"sns\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_sqs_client","title":"localstack_sqs_client  <code>async</code>","text":"<pre><code>localstack_sqs_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_sqs_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[SQSClient, None]:\n    async with get_session().create_client(\"sqs\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_ssm_client","title":"localstack_ssm_client  <code>async</code>","text":"<pre><code>localstack_ssm_client(localstack_container)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_container</code> <p> TYPE: <code>LocalStackContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def localstack_ssm_client(localstack_container: LocalStackContainer) -&gt; AsyncGenerator[SSMClient, None]:\n    async with get_session().create_client(\"ssm\", **localstack_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.localstack.localstack_snssqs_tc","title":"localstack_snssqs_tc","text":"<pre><code>localstack_snssqs_tc(localstack_sns_client, localstack_sqs_client)\n</code></pre> PARAMETER DESCRIPTION <code>localstack_sns_client</code> <p> TYPE: <code>SNSClient</code> </p> <code>localstack_sqs_client</code> <p> TYPE: <code>SQSClient</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/localstack.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef localstack_snssqs_tc(localstack_sns_client: SNSClient, localstack_sqs_client: SQSClient) -&gt; SNSSQSTestClient:\n    return SNSSQSTestClient(localstack_sns_client, localstack_sqs_client)\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.minio","title":"tomodachi_testcontainers.fixtures.minio","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.minio.minio_container","title":"minio_container","text":"<pre><code>minio_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/minio.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef minio_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"MINIO_TESTCONTAINER_IMAGE_ID\", \"minio/minio:latest\")\n    disable_logging = bool(os.getenv(\"MINIO_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with MinioContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.minio.minio_s3_client","title":"minio_s3_client  <code>async</code>","text":"<pre><code>minio_s3_client(minio_container)\n</code></pre> PARAMETER DESCRIPTION <code>minio_container</code> <p> TYPE: <code>MinioContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/minio.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def minio_s3_client(minio_container: MinioContainer) -&gt; AsyncGenerator[S3Client, None]:\n    async with get_session().create_client(\"s3\", **minio_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto","title":"tomodachi_testcontainers.fixtures.moto","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_container","title":"moto_container","text":"<pre><code>moto_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef moto_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"MOTO_TESTCONTAINER_IMAGE_ID\", \"motoserver/moto:latest\")\n    disable_logging = bool(os.getenv(\"MOTO_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with MotoContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.reset_moto_container_on_teardown","title":"reset_moto_container_on_teardown","text":"<pre><code>reset_moto_container_on_teardown(moto_container)\n</code></pre> <p>Removes all mocked resources from Moto after each test without restarting the container.</p> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> YIELDS DESCRIPTION <code>None</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest.fixture\ndef reset_moto_container_on_teardown(moto_container: MotoContainer) -&gt; Generator[None, None, None]:  # noqa: PT004\n    \"\"\"Removes all mocked resources from Moto after each test without restarting the container.\"\"\"\n    yield\n    moto_container.reset_moto()\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_dynamodb_client","title":"moto_dynamodb_client  <code>async</code>","text":"<pre><code>moto_dynamodb_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_dynamodb_client(moto_container: MotoContainer) -&gt; AsyncGenerator[DynamoDBClient, None]:\n    async with get_session().create_client(\"dynamodb\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_iam_client","title":"moto_iam_client  <code>async</code>","text":"<pre><code>moto_iam_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_iam_client(moto_container: MotoContainer) -&gt; AsyncGenerator[IAMClient, None]:\n    async with get_session().create_client(\"iam\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_lambda_client","title":"moto_lambda_client  <code>async</code>","text":"<pre><code>moto_lambda_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_lambda_client(moto_container: MotoContainer) -&gt; AsyncGenerator[LambdaClient, None]:\n    async with get_session().create_client(\"lambda\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_s3_client","title":"moto_s3_client  <code>async</code>","text":"<pre><code>moto_s3_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_s3_client(moto_container: MotoContainer) -&gt; AsyncGenerator[S3Client, None]:\n    async with get_session().create_client(\"s3\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_sns_client","title":"moto_sns_client  <code>async</code>","text":"<pre><code>moto_sns_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_sns_client(moto_container: MotoContainer) -&gt; AsyncGenerator[SNSClient, None]:\n    async with get_session().create_client(\"sns\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_sqs_client","title":"moto_sqs_client  <code>async</code>","text":"<pre><code>moto_sqs_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_sqs_client(moto_container: MotoContainer) -&gt; AsyncGenerator[SQSClient, None]:\n    async with get_session().create_client(\"sqs\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_ssm_client","title":"moto_ssm_client  <code>async</code>","text":"<pre><code>moto_ssm_client(moto_container)\n</code></pre> PARAMETER DESCRIPTION <code>moto_container</code> <p> TYPE: <code>MotoContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def moto_ssm_client(moto_container: MotoContainer) -&gt; AsyncGenerator[SSMClient, None]:\n    async with get_session().create_client(\"ssm\", **moto_container.get_aws_client_config()) as c:\n        yield c\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.moto.moto_snssqs_tc","title":"moto_snssqs_tc","text":"<pre><code>moto_snssqs_tc(moto_sns_client, moto_sqs_client)\n</code></pre> PARAMETER DESCRIPTION <code>moto_sns_client</code> <p> TYPE: <code>SNSClient</code> </p> <code>moto_sqs_client</code> <p> TYPE: <code>SQSClient</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/moto.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef moto_snssqs_tc(moto_sns_client: SNSClient, moto_sqs_client: SQSClient) -&gt; SNSSQSTestClient:\n    return SNSSQSTestClient(moto_sns_client, moto_sqs_client)\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.mysql","title":"tomodachi_testcontainers.fixtures.mysql","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.mysql.mysql_container","title":"mysql_container","text":"<pre><code>mysql_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/mysql.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef mysql_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"MYSQL_TESTCONTAINER_IMAGE_ID\", \"mysql:8\")\n    disable_logging = bool(os.getenv(\"MYSQL_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with MySQLContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.postgres","title":"tomodachi_testcontainers.fixtures.postgres","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.postgres.postgres_container","title":"postgres_container","text":"<pre><code>postgres_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/postgres.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef postgres_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"POSTGRES_TESTCONTAINER_IMAGE_ID\", \"postgres:16\")\n    disable_logging = bool(os.getenv(\"POSTGRES_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with PostgreSQLContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.sftp","title":"tomodachi_testcontainers.fixtures.sftp","text":""},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.sftp.sftp_container","title":"sftp_container","text":"<pre><code>sftp_container()\n</code></pre> YIELDS DESCRIPTION <code>DockerContainer</code> RECEIVES DESCRIPTION <code>None</code> RETURNS DESCRIPTION <code>None</code> Source code in <code>src/tomodachi_testcontainers/fixtures/sftp.py</code> <pre><code>@pytest.fixture(scope=\"session\")\ndef sftp_container() -&gt; Generator[DockerContainer, None, None]:\n    image = os.getenv(\"SFTP_TESTCONTAINER_IMAGE_ID\", \"atmoz/sftp:latest\")\n    disable_logging = bool(os.getenv(\"SFTP_TESTCONTAINER_DISABLE_LOGGING\")) or False\n\n    with SFTPContainer(image, disable_logging=disable_logging) as container:\n        yield container\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.sftp.userpass_sftp_client","title":"userpass_sftp_client  <code>async</code>","text":"<pre><code>userpass_sftp_client(sftp_container)\n</code></pre> PARAMETER DESCRIPTION <code>sftp_container</code> <p> TYPE: <code>SFTPContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/sftp.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def userpass_sftp_client(sftp_container: SFTPContainer) -&gt; AsyncGenerator[asyncssh.SFTPClient, None]:\n    conn_details = sftp_container.get_external_conn_details()\n    async with asyncssh.connect(\n        host=conn_details.host,\n        port=conn_details.port,\n        username=\"userpass\",\n        password=\"pass\",  # nosec: B106\n        known_hosts=sftp_container.get_known_hosts(),\n    ) as ssh_conn:\n        async with ssh_conn.start_sftp_client() as sftp_client:\n            yield sftp_client\n</code></pre>"},{"location":"reference/fixtures/#tomodachi_testcontainers.fixtures.sftp.userssh_sftp_client","title":"userssh_sftp_client  <code>async</code>","text":"<pre><code>userssh_sftp_client(sftp_container)\n</code></pre> PARAMETER DESCRIPTION <code>sftp_container</code> <p> TYPE: <code>SFTPContainer</code> </p> Source code in <code>src/tomodachi_testcontainers/fixtures/sftp.py</code> <pre><code>@pytest_asyncio.fixture(scope=\"session\", loop_scope=\"session\")\nasync def userssh_sftp_client(sftp_container: SFTPContainer) -&gt; AsyncGenerator[asyncssh.SFTPClient, None]:\n    conn_details = sftp_container.get_external_conn_details()\n    async with asyncssh.connect(\n        host=conn_details.host,\n        port=conn_details.port,\n        username=\"userssh\",\n        client_keys=sftp_container.authorized_private_key,\n        known_hosts=sftp_container.get_known_hosts(),\n    ) as ssh_conn:\n        async with ssh_conn.start_sftp_client() as sftp_client:\n            yield sftp_client\n</code></pre>"},{"location":"reference/utils/","title":"Utils module","text":""},{"location":"reference/utils/#tomodachi_testcontainers.utils","title":"tomodachi_testcontainers.utils","text":""},{"location":"reference/utils/#tomodachi_testcontainers.utils.AWSClientConfig","title":"AWSClientConfig","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.AWSClientConfig.region_name","title":"region_name  <code>instance-attribute</code>","text":"<pre><code>region_name\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.AWSClientConfig.aws_access_key_id","title":"aws_access_key_id  <code>instance-attribute</code>","text":"<pre><code>aws_access_key_id\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.AWSClientConfig.aws_secret_access_key","title":"aws_secret_access_key  <code>instance-attribute</code>","text":"<pre><code>aws_secret_access_key\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.AWSClientConfig.endpoint_url","title":"endpoint_url  <code>instance-attribute</code>","text":"<pre><code>endpoint_url\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.get_docker_image","title":"get_docker_image","text":"<pre><code>get_docker_image(image_id, docker_client_kwargs=None)\n</code></pre> <p>Returns a Docker image, pulling it if not exists on host.</p> PARAMETER DESCRIPTION <code>image_id</code> <p> TYPE: <code>str</code> </p> <code>docker_client_kwargs</code> <p> TYPE: <code>Optional[Dict]</code> DEFAULT: <code>None</code> </p> Source code in <code>src/tomodachi_testcontainers/utils.py</code> <pre><code>def get_docker_image(image_id: str, docker_client_kwargs: Optional[Dict] = None) -&gt; Image:\n    \"\"\"Returns a Docker image, pulling it if not exists on host.\"\"\"\n    client = DockerClient(**(docker_client_kwargs or {}))\n    try:\n        return cast(Image, client.client.images.get(image_id))\n    except ImageNotFound:\n        return cast(Image, client.client.images.pull(image_id))\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.copy_files_to_container","title":"copy_files_to_container","text":"<pre><code>copy_files_to_container(container, host_path, container_path)\n</code></pre> <p>Copies a folder or a file from the host to the container.</p> PARAMETER DESCRIPTION <code>container</code> <p> TYPE: <code>Container</code> </p> <code>host_path</code> <p> TYPE: <code>Path</code> </p> <code>container_path</code> <p> TYPE: <code>Path</code> </p> Source code in <code>src/tomodachi_testcontainers/utils.py</code> <pre><code>def copy_files_to_container(container: Container, host_path: Path, container_path: Path) -&gt; None:\n    \"\"\"Copies a folder or a file from the host to the container.\"\"\"\n    tar_stream = io.BytesIO()\n    with tarfile.open(fileobj=tar_stream, mode=\"w\") as tar:\n        if host_path.is_dir():\n            for root, _, files in os.walk(host_path):\n                for file in files:\n                    file_path = Path(root) / file\n                    arcname = os.path.relpath(file_path, host_path)\n                    tar.add(file_path, arcname=arcname)\n        else:\n            tar.add(host_path, arcname=host_path.name)\n    tar_stream.seek(0)\n    container.put_archive(path=container_path, data=tar_stream)\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.copy_files_from_container","title":"copy_files_from_container","text":"<pre><code>copy_files_from_container(container, container_path, host_path)\n</code></pre> <p>Copies a folder or a file from the container to the host.</p> PARAMETER DESCRIPTION <code>container</code> <p> TYPE: <code>Container</code> </p> <code>container_path</code> <p> TYPE: <code>Path</code> </p> <code>host_path</code> <p> TYPE: <code>Path</code> </p> Source code in <code>src/tomodachi_testcontainers/utils.py</code> <pre><code>def copy_files_from_container(container: Container, container_path: Path, host_path: Path) -&gt; None:\n    \"\"\"Copies a folder or a file from the container to the host.\"\"\"\n    tar_stream, _ = container.get_archive(container_path)\n    with tarfile.open(fileobj=io.BytesIO(b\"\".join(tar_stream))) as tar:\n        tar.extractall(path=host_path)  # nosec: B202\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.get_available_port","title":"get_available_port","text":"<pre><code>get_available_port()\n</code></pre> <p>Returns a random available port on the host.</p> Source code in <code>src/tomodachi_testcontainers/utils.py</code> <pre><code>def get_available_port() -&gt; int:\n    \"\"\"Returns a random available port on the host.\"\"\"\n    with socket.socket() as sock:\n        sock.bind((\"\", 0))\n        return int(sock.getsockname()[1])\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.get_current_ip_address","title":"get_current_ip_address","text":"<pre><code>get_current_ip_address()\n</code></pre> <p>Returns the current IP address of the host.</p> Source code in <code>src/tomodachi_testcontainers/utils.py</code> <pre><code>def get_current_ip_address() -&gt; str:\n    \"\"\"Returns the current IP address of the host.\"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:\n        sock.connect((\"8.8.8.8\", 80))\n        return str(sock.getsockname()[0])\n</code></pre>"},{"location":"reference/utils/#tomodachi_testcontainers.utils.setup_logger","title":"setup_logger","text":"<pre><code>setup_logger(name)\n</code></pre> <p>Outputs logs to stderr for better visibility in pytest output.</p> <p>Inspired by testcontainers.core.utils.setup_logger</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> Source code in <code>src/tomodachi_testcontainers/utils.py</code> <pre><code>def setup_logger(name: str) -&gt; logging.Logger:\n    \"\"\"Outputs logs to stderr for better visibility in pytest output.\n\n    Inspired by testcontainers.core.utils.setup_logger\n    \"\"\"\n    logger = logging.getLogger(name)\n    logger.setLevel(logging.INFO)\n    handler = logging.StreamHandler()\n    handler.setLevel(logging.INFO)\n    handler.setFormatter(logging.Formatter(fmt=\"%(name)s: %(message)s\"))\n    logger.addHandler(handler)\n    return logger\n</code></pre>"}]}